<html><!-- Mirrored from developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 01 May 2019 23:20:32 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->

  <meta charset="utf-8">

  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <script async="" src="../../../../../../www.google-analytics.com/analytics.js"></script><script>(function(d) { d.className = d.className.replace(/\bno-js/, ''); })(document.documentElement);</script>
  <title>Signaling and video calling</title>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="index, follow">

  
<link rel="preload" href="../../../../../static/fonts/locales/ZillaSlab-Regular.subset.bbc33fb47cf6.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="home" href="https://developer.mozilla.org/en-US/">
    <link rel="license" href="#license">
  

  
    
    

    <link href="../../../../../static/build/styles/mdn.8634e046f072.css" rel="stylesheet" type="text/css">

    
  
    <link href="../../../../../static/build/styles/wiki.d451415ae2dd.css" rel="stylesheet" type="text/css">


    

  <link href="../../../../../static/build/styles/locale-en-US.520ecdcaef8c.css" rel="stylesheet" type="text/css">

  
    
  

  
    <script>
    // util for setting performance marks and mesaures
    var mdn=window.mdn||{};mdn.perf={getDuration:function(e){"use strict";if(void 0!==performance.getEntriesByName)return performance.getEntriesByName(e)[0].duration;console.error("performance.getEntriesByName is not supported by your user-agent")},setMark:function(e){"use strict";if(void 0!==performance.mark)try{performance.mark(e)}catch(e){console.error("Error while setting performance mark: ",e)}else console.error("performance.mark is not supported by your user-agent")},setMeasure:function(e){"use strict";void 0!==performance.measure?performance.measure(e.measureName,e.startMark,e.endMark):console.error("performance.measure is not supported by your user-agent")}};
    /* util specifically for postMessages sent from the
       `head` of the interactive examples iframe */
    function handlePerfMarks(e){e.measureName?(window.mdn.perf.setMark(e.markName),window.mdn.perf.setMeasure({measureName:e.measureName,startMark:e.startMark,endMark:e.endMark}),ga&&ga.create&&ga("send",{hitType:"timing",timingCategory:"RUM - Interactive Examples",timingVar:e.measureName,timingValue:window.mdn.perf.getDuration(e.measureName)||0})):window.mdn.perf.setMark(e.markName)}function perfMsgHandler(e){"use strict";var a=window.mdn.interactiveEditor.editorUrl||"https://interactive-examples.mdn.mozilla.net",r=e.data;if(e.origin!==a)return!1;r.markName&&-1<r.markName.indexOf("interactive-editor-")&&handlePerfMarks(r)}window.addEventListener("message",perfMsgHandler,!1);
</script>

    <!-- common social tags -->
    
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://developer.mozilla.org/static/img/opengraph-logo.72382e605ce3.png">
    <meta property="og:site_name" content="MDN Web Docs">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:image" content="https://developer.mozilla.org/static/img/opengraph-logo.72382e605ce3.png">
    <meta name="twitter:site" content="@MozDevNet">
    <meta name="twitter:creator" content="@MozDevNet">
    <link rel="search" type="application/opensearchdescription+xml" href="https://developer.mozilla.org/en-US/search/xml" title="MDN Web Docs">
    
  
  <!-- third-generation iPad with high-resolution Retina display: -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../../../static/img/favicon144.e7e21ca263ca.png">
  <!-- iPhone with high-resolution Retina display: -->
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../../../../static/img/favicon114.d526f38b09c5.png">
  <!-- first- and second-generation iPad: -->
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../../../../../static/img/favicon72.cc65d1d762a0.png">
  <!-- non-Retina iPhone, iPod Touch, and Android 2.1+ devices: -->
  <link rel="apple-touch-icon-precomposed" href="../../../../../static/img/favicon57.de33179910ae.png">
  <!-- basic favicon -->
  <link rel="shortcut icon" href="../../../../../static/img/favicon32.7f3da72dcea1.png">
  <!--[if IE]>
  <meta http-equiv="imagetoolbar" content="no">
  <script async="" type="text/javascript" src=".html5shiv.ae1ac46eaf58.js" charset="utf-8"></script>
  <![endif]-->

  
  <link rel="dns-prefetch" href="../../../../../../interactive-examples.mdn.mozilla.net/index.html" pr="0.75">
  <link rel="preconnect" href="../../../../../../interactive-examples.mdn.mozilla.net/index.html" pr="0.75">

  <link rel="alternate" type="application/json" href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling$json">
  <link rel="canonical" href="Signaling_and_video_calling.html">

  
  <link rel="alternate" hreflang="en" href="Signaling_and_video_calling.html" title="Signaling and video calling">
  
    
      <link rel="alternate" hreflang="ko" href="https://developer.mozilla.org/ko/docs/Web/API/WebRTC_API/Signaling_and_video_calling" title="Signaling and video calling">
    
      <link rel="alternate" hreflang="zh" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API/Signaling_and_video_calling" title="Signaling and video calling">
    
  

  <!-- document-specific social tags -->
  <meta property="og:title" content="Signaling and video calling">
  <meta property="og:url" content="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling">
  <meta name="twitter:url" content="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling">
  <meta name="twitter:title" content="Signaling and video calling">
  
  <meta property="og:description" content="WebRTC allows real-time, peer-to-peer, media exchange between two devices. A connection is established through a discovery and negotiation process called signaling. This tutorial will guide you through building a two-way video-call.">
  <meta name="description" content="WebRTC allows real-time, peer-to-peer, media exchange between two devices. A connection is established through a discovery and negotiation process called signaling. This tutorial will guide you through building a two-way video-call.">
  <meta name="twitter:description" content="WebRTC allows real-time, peer-to-peer, media exchange between two devices. A connection is established through a discovery and negotiation process called signaling. This tutorial will guide you through building a two-way video-call.">
  

</head>
<body data-slug="Web/API/WebRTC_API/Signaling_and_video_calling" contextmenu="edit-history-menu" data-search-url="" class="document">

  <script>
    // make sure global mdn object exists
    var mdn = window.mdn || {};

    (function(win) {
        'use strict';

        (function(){
  var FLAGS = {
    'kumaediting': false,'page_move': false,'section_edit': false,'spam_checks_enabled': true,'spam_submissions_enabled': false,'spam_admin_override': false,'spam_spammer_override': false,'spam_testing_mode': false,'sg_task_completion': false,'contrib_beta': false,'recurring_payment_beta': false
    },
    SWITCHES = {
    'welcome_email': true,'application_ACAO': true,'store_revision_ips': true,'foundation_callout': false,'helpful-survey-2': true,'wiki_spam_training': true,'registration_disabled': false
    },
    SAMPLES = {
    
    };
  window.waffle = {
    "flag_is_active": function waffle_flag(flag_name) {
      
      return !!FLAGS[flag_name];
    },
    "switch_is_active": function waffle_switch(switch_name) {
      
      return !!SWITCHES[switch_name];
    },
    "sample_is_active": function waffle_sample(sample_name) {
      
      return !!SAMPLES[sample_name];
    },
    "FLAGS": FLAGS,
    "SWITCHES": SWITCHES,
    "SAMPLES": SAMPLES
  };
})();

        // This needs to be set before ckeditor.js loads
        window.CKEDITOR_BASEPATH = 'https://developer.mozilla.org/static/js/libs/ckeditor4/build/ckeditor/';

        // Site configuration
        win.mdn.ckeditor = {};
        win.mdn.features = {};
        win.mdn.siteUrl = 'https://developer.mozilla.org/';
        win.mdn.wikiSiteUrl = 'https://wiki.developer.mozilla.org/';
        win.mdn.staticPath = 'https://developer.mozilla.org/static/';
        win.mdn.wiki = {
            autosuggestTitleUrl: '/en-US/docs/get-documents'
        };
        win.mdn.assets_disabled = {
            css: {
                'editor-content': ['https://developer.mozilla.org/static/build/styles/editor-content.c9f73a799d9a.css','../../../../../static/build/styles/editor-locale-en-US.520ecdcaef8c.css',
                ],

                'wiki-compat-tables': ['https://developer.mozilla.org/static/build/styles/wiki-compat-tables.eef64bf9b6fe.css',]
            },
            js: {
                'syntax-prism': ['https://developer.mozilla.org/static/build/js/syntax-prism.f016806edde4.js',],
                'wiki-compat-tables': ['https://developer.mozilla.org/static/build/js/syntax-prism.js" charset="utf-8"></script><script type="text/javascript" src=".html5shiv.ae1ac46eaf58.js" charset="utf-8"></script>
  <!--[endif]---->

  
  <link rel="dns-prefetch" href="../../../../../../interactive-examples.mdn.mozilla.net/index.html" pr="0.75">
  <link rel="preconnect" href="../../../../../../interactive-examples.mdn.mozilla.net/index.html" pr="0.75">

  <link rel="alternate" type="application/json" href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling$json">
  <link rel="canonical" href="Signaling_and_video_calling.html">

  
  <link rel="alternate" hreflang="en" href="Signaling_and_video_calling.html" title="Signaling and video calling">
  
    
      <link rel="alternate" hreflang="ko" href="https://developer.mozilla.org/ko/docs/Web/API/WebRTC_API/Signaling_and_video_calling" title="Signaling and video calling">
    
      <link rel="alternate" hreflang="zh" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API/Signaling_and_video_calling" title="Signaling and video calling">
    
  

  <!-- document-specific social tags -->
  <meta property="og:title" content="Signaling and video calling">
  <meta property="og:url" content="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling">
  <meta name="twitter:url" content="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling">
  <meta name="twitter:title" content="Signaling and video calling">
  
  <meta property="og:description" content="WebRTC allows real-time, peer-to-peer, media exchange between two devices. A connection is established through a discovery and negotiation process called signaling. This tutorial will guide you through building a two-way video-call.">
  <meta name="description" content="WebRTC allows real-time, peer-to-peer, media exchange between two devices. A connection is established through a discovery and negotiation process called signaling. This tutorial will guide you through building a two-way video-call.">
  <meta name="twitter:description" content="WebRTC allows real-time, peer-to-peer, media exchange between two devices. A connection is established through a discovery and negotiation process called signaling. This tutorial will guide you through building a two-way video-call.">
  




  <script>
    // make sure global mdn object exists
    var mdn = window.mdn || {};

    (function(win) {
        'use strict';

        (function(){
  var FLAGS = {
    'kumaediting': false,'page_move': false,'section_edit': false,'spam_checks_enabled': true,'spam_submissions_enabled': false,'spam_admin_override': false,'spam_spammer_override': false,'spam_testing_mode': false,'sg_task_completion': false,'contrib_beta': false,'recurring_payment_beta': false
    },
    SWITCHES = {
    'welcome_email': true,'application_ACAO': true,'store_revision_ips': true,'foundation_callout': false,'helpful-survey-2': true,'wiki_spam_training': true,'registration_disabled': false
    },
    SAMPLES = {
    
    };
  window.waffle = {
    "flag_is_active": function waffle_flag(flag_name) {
      
      return !!FLAGS[flag_name];
    },
    "switch_is_active": function waffle_switch(switch_name) {
      
      return !!SWITCHES[switch_name];
    },
    "sample_is_active": function waffle_sample(sample_name) {
      
      return !!SAMPLES[sample_name];
    },
    "FLAGS": FLAGS,
    "SWITCHES": SWITCHES,
    "SAMPLES": SAMPLES
  };
})();

        // This needs to be set before ckeditor.js loads
        window.CKEDITOR_BASEPATH = 'https://developer.mozilla.org/static/js/libs/ckeditor4/build/ckeditor/';

        // Site configuration
        win.mdn.ckeditor = {};
        win.mdn.features = {};
        win.mdn.siteUrl = 'https://developer.mozilla.org/';
        win.mdn.wikiSiteUrl = 'https://wiki.developer.mozilla.org/';
        win.mdn.staticPath = 'https://developer.mozilla.org/static/';
        win.mdn.wiki = {
            autosuggestTitleUrl: '/en-US/docs/get-documents'
        };
        win.mdn.assets_disabled = {
            css: {
                'editor-content': ['https://developer.mozilla.org/static/build/styles/editor-content.c9f73a799d9a.css','../../../../../static/build/styles/editor-locale-en-US.520ecdcaef8c.css',
                ],

                'wiki-compat-tables': ['https://developer.mozilla.org/static/build/styles/wiki-compat-tables.eef64bf9b6fe.css',]
            },
            js: {
                'syntax-prism': ['https://developer.mozilla.org/static/build/js/syntax-prism.f016806edde4.js',],
                'wiki-compat-tables': ['https://developer.mozilla.org/static/build/js/wiki-compat-tables.3a4ab2cc8ca1.js',]
            }
        };

        win.mdn.notifications = [];
        win.mdn.contributions = {
            enabled: true,
            popup: false
        };

        

        // interactive editor config
        win.mdn.interactiveEditor = {
            siteUrl: "https://developer.mozilla.org",
            editorUrl: "https://interactive-examples.mdn.mozilla.net"
        };
        win.mdn.langCookieName = "django_language";

    })(this);
</script>
    
    <ul id="nav-access">
  <li><a href="#content" id="skip-main">Skip to main content</a></li>
  <li><a id="skip-language" href="#language">Select language</a></li>
  <li><a href="#q" id="skip-search">Skip to search</a></li>
</ul>

    <!-- Header -->
    <header id="main-header" class="header-main">
      <a href="https://developer.mozilla.org/en-US/" class="logo">MDN Web Docs</a>
      <div class="nav-toolbox-wrapper">
        <nav id="main-nav" class="nav-main" role="navigation">
    <ul>
        <li class="nav-main-item">
            <a href="https://developer.mozilla.org/en-US/docs/Web">Technologies
                <svg class="icon icon-caret-down" xmlns="http://www.w3.org/2000/svg" width="16" height="28" viewBox="0 0 16 28"><path d="M16 11a.99.99 0 0 1-.297.703l-7 7C8.516 18.89 8.265 19 8 19s-.516-.109-.703-.297l-7-7A.996.996 0 0 1 0 11c0-.547.453-1 1-1h14c.547 0 1 .453 1 1z"></path></svg>
            </a>
            <div class="submenu js-submenu" id="nav-tech-submenu">
                <div class="submenu-column">
                  <ul>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML">HTML</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS">CSS</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">JavaScript</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Graphics">Graphics</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">HTTP</a></li>
                    <li><a href="../../API.html">APIs / DOM</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions">Browser Extensions</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/MathML">MathML</a></li>
                  </ul>
                </div>
            </div>
        </li>
        <li class="nav-main-item">
            <a href="https://developer.mozilla.org/en-US/docs/Learn">References &amp; Guides
                <svg class="icon icon-caret-down" xmlns="http://www.w3.org/2000/svg" width="16" height="28" viewBox="0 0 16 28"><path d="M16 11a.99.99 0 0 1-.297.703l-7 7C8.516 18.89 8.265 19 8 19s-.516-.109-.703-.297l-7-7A.996.996 0 0 1 0 11c0-.547.453-1 1-1h14c.547 0 1 .453 1 1z"></path></svg>
            </a>
            <div class="submenu js-submenu" id="nav-learn-submenu">
                <div class="submenu-column">
                  <ul>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Learn">Learn web development</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/Tutorials">Tutorials</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/Reference">References</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/Guide">Developer Guides</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility">Accessibility</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Games">Game development</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web">...more docs</a></li>
                  </ul>
                </div>
            </div>
        </li>
        <li class="nav-main-item">
            <a href="https://developer.mozilla.org/en-US/docs/MDN/Feedback">Feedback
                <svg class="icon icon-caret-down" xmlns="http://www.w3.org/2000/svg" width="16" height="28" viewBox="0 0 16 28"><path d="M16 11a.99.99 0 0 1-.297.703l-7 7C8.516 18.89 8.265 19 8 19s-.516-.109-.703-.297l-7-7A.996.996 0 0 1 0 11c0-.547.453-1 1-1h14c.547 0 1 .453 1 1z"></path></svg>
            </a>
            <div class="submenu js-submenu" id="nav-contact-submenu">
              <div class="submenu-column">
                <ul>
                  <li>
                      <a href="https://support.mozilla.org/">Get Firefox help
                          <svg class="icon icon-external-link" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28" aria-hidden="true"><path d="M22 14.5v5c0 2.484-2.016 4.5-4.5 4.5h-13A4.502 4.502 0 0 1 0 19.5v-13C0 4.016 2.016 2 4.5 2h11c.281 0 .5.219.5.5v1c0 .281-.219.5-.5.5h-11A2.507 2.507 0 0 0 2 6.5v13C2 20.875 3.125 22 4.5 22h13c1.375 0 2.5-1.125 2.5-2.5v-5c0-.281.219-.5.5-.5h1c.281 0 .5.219.5.5zM28 1v8c0 .547-.453 1-1 1a.99.99 0 0 1-.703-.297l-2.75-2.75L13.36 17.14c-.094.094-.234.156-.359.156s-.266-.063-.359-.156l-1.781-1.781c-.094-.094-.156-.234-.156-.359s.063-.266.156-.359L21.048 4.454l-2.75-2.75a.996.996 0 0 1-.297-.703c0-.547.453-1 1-1h8c.547 0 1 .453 1 1z"></path></svg>
                      </a>
                  </li>
                  <li>
                      <a href="https://stackoverflow.com/">Get web development help
                          <svg class="icon icon-external-link" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28" aria-hidden="true"><path d="M22 14.5v5c0 2.484-2.016 4.5-4.5 4.5h-13A4.502 4.502 0 0 1 0 19.5v-13C0 4.016 2.016 2 4.5 2h11c.281 0 .5.219.5.5v1c0 .281-.219.5-.5.5h-11A2.507 2.507 0 0 0 2 6.5v13C2 20.875 3.125 22 4.5 22h13c1.375 0 2.5-1.125 2.5-2.5v-5c0-.281.219-.5.5-.5h1c.281 0 .5.219.5.5zM28 1v8c0 .547-.453 1-1 1a.99.99 0 0 1-.703-.297l-2.75-2.75L13.36 17.14c-.094.094-.234.156-.359.156s-.266-.063-.359-.156l-1.781-1.781c-.094-.094-.156-.234-.156-.359s.063-.266.156-.359L21.048 4.454l-2.75-2.75a.996.996 0 0 1-.297-.703c0-.547.453-1 1-1h8c.547 0 1 .453 1 1z"></path></svg>
                      </a>
                  </li>
                </ul>
                <ul>
                  <li>
                      <a href="https://developer.mozilla.org/en-US/docs/MDN/Community">Join the MDN community</a>
                  </li>
                  <li>
                      <a target="_blank" rel="noopener" href="https://github.com/mdn/sprints/issues/new?template=issue-template.md&amp;projects=mdn/sprints/2&amp;labels=user-report&amp;title=https%3A//developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling">Report a content problem
                          <svg class="icon icon-external-link" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28" aria-hidden="true"><path d="M22 14.5v5c0 2.484-2.016 4.5-4.5 4.5h-13A4.502 4.502 0 0 1 0 19.5v-13C0 4.016 2.016 2 4.5 2h11c.281 0 .5.219.5.5v1c0 .281-.219.5-.5.5h-11A2.507 2.507 0 0 0 2 6.5v13C2 20.875 3.125 22 4.5 22h13c1.375 0 2.5-1.125 2.5-2.5v-5c0-.281.219-.5.5-.5h1c.281 0 .5.219.5.5zM28 1v8c0 .547-.453 1-1 1a.99.99 0 0 1-.703-.297l-2.75-2.75L13.36 17.14c-.094.094-.234.156-.359.156s-.266-.063-.359-.156l-1.781-1.781c-.094-.094-.156-.234-.156-.359s.063-.266.156-.359L21.048 4.454l-2.75-2.75a.996.996 0 0 1-.297-.703c0-.547.453-1 1-1h8c.547 0 1 .453 1 1z"></path></svg>
                      </a>
                  </li>
                  <li>
                      <a target="_blank" rel="noopener" href="https://bugzilla.mozilla.org/form.mdn">Report a bug
                          <svg class="icon icon-external-link" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28" aria-hidden="true"><path d="M22 14.5v5c0 2.484-2.016 4.5-4.5 4.5h-13A4.502 4.502 0 0 1 0 19.5v-13C0 4.016 2.016 2 4.5 2h11c.281 0 .5.219.5.5v1c0 .281-.219.5-.5.5h-11A2.507 2.507 0 0 0 2 6.5v13C2 20.875 3.125 22 4.5 22h13c1.375 0 2.5-1.125 2.5-2.5v-5c0-.281.219-.5.5-.5h1c.281 0 .5.219.5.5zM28 1v8c0 .547-.453 1-1 1a.99.99 0 0 1-.703-.297l-2.75-2.75L13.36 17.14c-.094.094-.234.156-.359.156s-.266-.063-.359-.156l-1.781-1.781c-.094-.094-.156-.234-.156-.359s.063-.266.156-.359L21.048 4.454l-2.75-2.75a.996.996 0 0 1-.297-.703c0-.547.453-1 1-1h8c.547 0 1 .453 1 1z"></path></svg>
                      </a>
                  </li>
                </ul>
              </div>
          </div>
      </li>
  </ul>
</nav>
        <div id="toolbox" class="toolbox">
  <ul>
    
    <li class="nav-login"><div class="login">
    
        
        <a href="https://developer.mozilla.org/users/github/login/?next=%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWebRTC_API%2FSignaling_and_video_calling" class="login-link js-login-link" data-service="GitHub" rel="nofollow">
            Sign in<svg class="icon icon-github" xmlns="http://www.w3.org/2000/svg" width="24" height="28" viewBox="0 0 24 28" aria-label="GitHub" role="img" focusable="false">
    <title>Github</title>
    <path d="M12 2c6.625 0 12 5.375 12 12 0 5.297-3.437 9.797-8.203 11.391-.609.109-.828-.266-.828-.578 0-.391.016-1.687.016-3.297 0-1.125-.375-1.844-.812-2.219 2.672-.297 5.484-1.313 5.484-5.922 0-1.313-.469-2.375-1.234-3.219.125-.313.531-1.531-.125-3.187-1-.313-3.297 1.234-3.297 1.234a11.28 11.28 0 0 0-6 0S6.704 6.656 5.704 6.969c-.656 1.656-.25 2.875-.125 3.187-.766.844-1.234 1.906-1.234 3.219 0 4.594 2.797 5.625 5.469 5.922-.344.313-.656.844-.766 1.609-.688.313-2.438.844-3.484-1-.656-1.141-1.844-1.234-1.844-1.234-1.172-.016-.078.734-.078.734.781.359 1.328 1.75 1.328 1.75.703 2.141 4.047 1.422 4.047 1.422 0 1 .016 1.937.016 2.234 0 .313-.219.688-.828.578C3.439 23.796.002 19.296.002 13.999c0-6.625 5.375-12 12-12zM4.547 19.234c.031-.063-.016-.141-.109-.187-.094-.031-.172-.016-.203.031-.031.063.016.141.109.187.078.047.172.031.203-.031zm.484.532c.063-.047.047-.156-.031-.25-.078-.078-.187-.109-.25-.047-.063.047-.047.156.031.25.078.078.187.109.25.047zm.469.703c.078-.063.078-.187 0-.297-.063-.109-.187-.156-.266-.094-.078.047-.078.172 0 .281s.203.156.266.109zm.656.656c.063-.063.031-.203-.063-.297-.109-.109-.25-.125-.313-.047-.078.063-.047.203.063.297.109.109.25.125.313.047zm.891.391c.031-.094-.063-.203-.203-.25-.125-.031-.266.016-.297.109s.063.203.203.234c.125.047.266 0 .297-.094zm.984.078c0-.109-.125-.187-.266-.172-.141 0-.25.078-.25.172 0 .109.109.187.266.172.141 0 .25-.078.25-.172zm.906-.156c-.016-.094-.141-.156-.281-.141-.141.031-.234.125-.219.234.016.094.141.156.281.125s.234-.125.219-.219z"></path>
</svg>
        </a>
    
</div></li>
  </ul>
</div>
      </div>
      <form id="nav-main-search" action="https://developer.mozilla.org/en-US/search" method="get" role="search" class="nav-main-search">
  <div class="search-wrap">
    <label for="main-q" class="offscreen">Search</label>
    <input type="search" id="main-q" name="q" placeholder="Search" data-value="" value="" aria-hidden="true">
    <span class="search-trigger">
        <svg class="icon icon-search" xmlns="http://www.w3.org/2000/svg" width="26" height="28" viewBox="0 0 26 28" aria-hidden="true">
    <path d="M18 13c0-3.859-3.141-7-7-7s-7 3.141-7 7 3.141 7 7 7 7-3.141 7-7zm8 13c0 1.094-.906 2-2 2a1.96 1.96 0 0 1-1.406-.594l-5.359-5.344a10.971 10.971 0 0 1-6.234 1.937c-6.078 0-11-4.922-11-11s4.922-11 11-11 11 4.922 11 11c0 2.219-.672 4.406-1.937 6.234l5.359 5.359c.359.359.578.875.578 1.406z"></path>
</svg>
    </span>
    <button type="submit" class="offscreen">Search</button>
    <button type="button" id="close-header-search" class="close-header-search transparent">
        <span class="offscreen">Close search</span>
        <svg class="icon icon-close" xmlns="http://www.w3.org/2000/svg" width="22" height="28" viewBox="0 0 22 28" aria-hidden="true" role="img"><title></title><path d="M20.281 20.656c0 .391-.156.781-.438 1.062l-2.125 2.125c-.281.281-.672.438-1.062.438s-.781-.156-1.062-.438L11 19.249l-4.594 4.594c-.281.281-.672.438-1.062.438s-.781-.156-1.062-.438l-2.125-2.125c-.281-.281-.438-.672-.438-1.062s.156-.781.438-1.062L6.751 15l-4.594-4.594c-.281-.281-.438-.672-.438-1.062s.156-.781.438-1.062l2.125-2.125c.281-.281.672-.438 1.062-.438s.781.156 1.062.438L11 10.751l4.594-4.594c.281-.281.672-.438 1.062-.438s.781.156 1.062.438l2.125 2.125c.281.281.438.672.438 1.062s-.156.781-.438 1.062L15.249 15l4.594 4.594c.281.281.438.672.438 1.062z"></path></svg>
    </button>
  </div>
</form>
    </header>  

  <!-- Content will go here -->
  <main id="content">
      
  <!-- heading -->
  <div id="wiki-document-head" class="document-head">
    <div class="center">
      <div class="document-title">
        <h1>Signaling and video calling</h1>
      </div>

      <!-- action buttons -->
      <div class="document-actions">
        

  
    
  

  
    
    
        
    
  

  

  <ul class="page-buttons">
      <li>
          <button id="languages-menu" class="transparent" aria-haspopup="true" aria-owns="languages-menu-submenu" aria-expanded="false">
              <svg class="icon icon-language" xmlns="http://www.w3.org/2000/svg" width="24" height="28" viewBox="0 0 24 28" aria-hidden="true">
    <path d="M10.219 16.844c-.031.109-.797-.25-1-.328-.203-.094-1.125-.609-1.359-.766s-1.125-.891-1.234-.938a28.275 28.275 0 0 1-2.094 2.828c-.281.328-1.125 1.391-1.641 1.719-.078.047-.531.094-.594.063.25-.187.969-1.078 1.281-1.437.391-.453 2.25-3.047 2.562-3.641.328-.594 1.312-2.562 1.359-2.75-.156-.016-1.391.406-1.719.516-.313.094-1.172.297-1.234.344-.063.063-.016.25-.047.313s-.313.203-.484.234a1.647 1.647 0 0 1-.734 0c-.203-.047-.391-.25-.438-.328 0 0-.063-.094-.078-.359.187-.063.5-.078.844-.172s1.188-.344 1.641-.5 1.328-.484 1.594-.547c.281-.047.984-.516 1.359-.641s.641-.281.656-.203 0 .422-.016.516c-.016.078-.766 1.547-.875 1.781-.063.125-.5.953-1.203 2.047.25.109.781.328 1 .438.266.125 2.125.906 2.219.938s.266.75.234.875zM7.016 9.25c.047.266-.031.375-.063.438-.156.297-.547.5-.781.594s-.625.187-.938.187c-.141-.016-.422-.063-.766-.406-.187-.203-.328-.75-.266-.688s.516.125.719.078.688-.187.906-.25c.234-.078.703-.203.859-.219.156 0 .281.063.328.266zm10.906 2.016l.984 3.547-2.172-.656zM.609 23.766l10.844-3.625V4.016L.609 7.657v16.109zM20 18.813l1.594.484-2.828-10.266-1.563-.484-3.375 8.375 1.594.484.703-1.719 3.297 1.016zM12.141 3.781l8.953 2.875V.718zM17 24.453l2.469.203-.844 2.5L18 26.125c-1.266.812-2.828 1.437-4.312 1.687-.453.094-.969.187-1.422.187h-1.313c-1.656 0-4.672-.984-5.984-1.937-.094-.078-.125-.141-.125-.25 0-.172.125-.297.281-.297.141 0 .875.453 1.078.547 1.406.703 3.375 1.344 4.953 1.344 1.953 0 3.281-.25 5.063-1.016.516-.234.969-.531 1.453-.797zm7-16.859v16.859c-12.078-3.844-12.094-3.844-12.094-3.844C11.656 20.718.453 24.5.297 24.5a.3.3 0 0 1-.281-.203c0-.016-.016-.031-.016-.047V7.406c.016-.047.031-.125.063-.156.094-.109.219-.141.313-.172.047-.016 1-.328 2.328-.781v-6l8.719 3.094C11.532 3.36 21.251 0 21.392 0c.172 0 .313.125.313.328v6.531z"></path>
</svg>
              <span>Languages</span>
          </button>

        <div class="submenu js-submenu" id="languages-menu-submenu">
          <div class="submenu-column">
            <ul id="translations">
              
                
                
                
                  <li lang="ko"><bdi><a rel="internal" href="https://developer.mozilla.org/ko/docs/Web/API/WebRTC_API/Signaling_and_video_calling" data-locale="ko" title="Korean">한국어 (ko)</a></bdi></li>
                
                  <li lang="zh-CN"><bdi><a rel="internal" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API/Signaling_and_video_calling" data-locale="zh-CN" title="Chinese (Simplified)">中文 (简体) (zh-CN)</a></bdi></li>
                
              

              
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling$locales" rel="nofollow" id="translations-add">Add a translation</a></li>
              
            </ul>
          </div>
        </div>
      </li>
      
      <li class="page-buttons-edit">
          <a href="https://developer.mozilla.org/en-US/users/signin?next=/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling%24edit" class="button neutral" id="edit-button" rel="nofollow">
              <svg class="icon icon-pencil" xmlns="http://www.w3.org/2000/svg" width="24" height="28" viewBox="0 0 24 28" aria-hidden="true">
    <path d="M5.672 24l1.422-1.422-3.672-3.672L2 20.328V22h2v2h1.672zm8.172-14.5a.329.329 0 0 0-.344-.344.368.368 0 0 0-.266.109l-8.469 8.469a.366.366 0 0 0-.109.266c0 .203.141.344.344.344a.368.368 0 0 0 .266-.109l8.469-8.469a.366.366 0 0 0 .109-.266zM13 6.5l6.5 6.5-13 13H0v-6.5zM23.672 8c0 .531-.219 1.047-.578 1.406L20.5 12 14 5.5l2.594-2.578c.359-.375.875-.594 1.406-.594s1.047.219 1.422.594l3.672 3.656c.359.375.578.891.578 1.422z"></path>
</svg>
              Edit
          </a>
      </li>
      

        

        <li class="page-buttons-advanced">
            <button id="advanced-menu" class="only-icon" aria-haspopup="true" aria-owns="advanced-menu-submenu" aria-expanded="false">
                <svg class="icon icon-gear" xmlns="http://www.w3.org/2000/svg" width="24" height="28" viewBox="0 0 24 28" aria-hidden="true">
    <path d="M16 14c0-2.203-1.797-4-4-4s-4 1.797-4 4 1.797 4 4 4 4-1.797 4-4zm8-1.703v3.469c0 .234-.187.516-.438.562l-2.891.438a8.86 8.86 0 0 1-.609 1.422c.531.766 1.094 1.453 1.672 2.156.094.109.156.25.156.391s-.047.25-.141.359c-.375.5-2.484 2.797-3.016 2.797a.795.795 0 0 1-.406-.141l-2.156-1.687a9.449 9.449 0 0 1-1.422.594c-.109.953-.203 1.969-.453 2.906a.573.573 0 0 1-.562.438h-3.469c-.281 0-.531-.203-.562-.469l-.438-2.875a9.194 9.194 0 0 1-1.406-.578l-2.203 1.672c-.109.094-.25.141-.391.141s-.281-.063-.391-.172c-.828-.75-1.922-1.719-2.578-2.625a.607.607 0 0 1 .016-.718c.531-.719 1.109-1.406 1.641-2.141a8.324 8.324 0 0 1-.641-1.547l-2.859-.422A.57.57 0 0 1 0 15.705v-3.469c0-.234.187-.516.422-.562l2.906-.438c.156-.5.359-.969.609-1.437a37.64 37.64 0 0 0-1.672-2.156c-.094-.109-.156-.234-.156-.375s.063-.25.141-.359c.375-.516 2.484-2.797 3.016-2.797.141 0 .281.063.406.156L7.828 5.94a9.449 9.449 0 0 1 1.422-.594c.109-.953.203-1.969.453-2.906a.573.573 0 0 1 .562-.438h3.469c.281 0 .531.203.562.469l.438 2.875c.484.156.953.344 1.406.578l2.219-1.672c.094-.094.234-.141.375-.141s.281.063.391.156c.828.766 1.922 1.734 2.578 2.656a.534.534 0 0 1 .109.344c0 .141-.047.25-.125.359-.531.719-1.109 1.406-1.641 2.141.266.5.484 1.016.641 1.531l2.859.438a.57.57 0 0 1 .453.562z"></path>
</svg>
                <span>Advanced</span>
            </button>
            <div class="submenu js-submenu" id="advanced-menu-submenu">
                <!-- this page -->
                <div class="submenu-column">
                    <div class="title">Advanced</div>
                    <ul>
                        <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling$history" rel="nofollow">History</a></li>
                        
                        
                        


                

                <li class="page-print"><a href="#" onclick="return window.print();">Print this article</a></li>
            </ul>
          </div>
        </div>
  </li></ul>
      </div>
    <nav class="crumbs" role="navigation">
      <ol typeof="BreadcrumbList" vocab="https://schema.org/" aria-label="breadcrumbs">
        
          <li property="itemListElement" typeof="ListItem" class="crumb">
            <a href="https://developer.mozilla.org/en-US/docs/Web" property="item" typeof="WebPage">
              <span property="name">Web technology for developers</span>
            </a>
            <meta property="position" content="1">
          </li>
        
          <li property="itemListElement" typeof="ListItem" class="crumb">
            <a href="../../API.html" property="item" typeof="WebPage">
              <span property="name">Web APIs</span>
            </a>
            <meta property="position" content="2">
          </li>
        
          <li property="itemListElement" typeof="ListItem" class="crumb">
            <a href="../WebRTC_API.html" property="item" typeof="WebPage">
              <span property="name">WebRTC API</span>
            </a>
            <meta property="position" content="3">
          </li>
        
        <li property="itemListElement" typeof="ListItem" class="crumb">
          <span property="name" aria-current="page">Signaling and video calling</span>
        </li>
      </ol>
    </nav></div>
  </div>
  
  <div id="toc" class="toc">
    <div class="center">
      <div class="toc-head">Jump to:</div>
        <ol class="toc-links">
          <li><a href="#The_signaling_server" rel="internal">The signaling server</a></li><li><a href="#The_client_application" rel="internal">The client application</a></li><li><a href="#Next_steps" rel="internal">Next steps</a>
        </li></ol>
    </div>
  </div>
  

      <div class="center clear">
      

    <div class="wiki-main-content" id="document-main"><div class="center">
      <!-- start the main content container -->
        <div id="wiki-column-container" class="wiki-left-present">

          <!-- content row with three strips -->
          <div class="column-container column-container-reverse">

            <!-- center: main article content -->
            <div id="wiki-content" class="column-main wiki-column text-content">

              

              
              

              

              
              

              <!-- just the article content -->
              <article id="wikiArticle">
                
                  
                    <div></div>

<p><span class="seoSummary"><a href="../WebRTC_API.html">WebRTC</a> allows real-time, peer-to-peer, media exchange between two devices. A connection is established through a discovery and negotiation process called <strong>signaling</strong>. This tutorial will guide you through building a two-way video-call.</span></p>

<p><a href="../WebRTC_API.html">WebRTC</a> is a fully peer-to-peer technology for the real-time exchange of audio, video, and data, with one central caveat. A form of discovery and media format negotiation must take place, <a href="Session_lifetime.html#Establishing_a_connection">as discussed elsewhere</a>, in order for two devices on different networks to locate one another. This process is called <strong>signaling</strong> and involves both devices connecting to a third, mutually agreed-upon server. Through this third server, the two devices can locate one another, and exchange negotiation messages.</p>

<p>In this article, we will further enhance the <a class="external external-icon" href="https://webrtc-from-chat.glitch.me/" rel="noopener">WebSocket chat</a> first created as part of our WebSocket documentation (this article link is forthcoming; it isn't actually online yet) to support opening a two-way video call between users. You can <a class="external" href="https://webrtc-from-chat.glitch.me/" rel="noopener">try out this example on Glitch</a>, and you can <a class="external" href="https://glitch.com/edit/#!/remix/webrtc-from-chat" rel="noopener">remix the example</a> to experiment with it as well. You can also <a class="external" href="https://github.com/mdn/samples-server/tree/master/s/webrtc-from-chat" rel="noopener">look at the full project</a> on GitHub.</p>

<div class="note">
<p><strong>Note:</strong> If you try out the example on Glitch, please note that any changes made to the code will immediately reset any connections. In addition, there is a short timeout period; the Glitch instance is for quick experiments and testing only.</p>
</div>

<a class="dashAnchor" name="//apple_ref/Section/The%20signaling%20server"></a><h2 id="The_signaling_server">The signaling server</h2>

<p>Establishing a WebRTC connection between two devices requires the use of a <strong>signaling server</strong> to resolve how to connect them over the internet. A signaling server's job is to serve as an intermediary to let two peers find and establish a connection while minimizing exposure of potentially private information as much as possible. How do we create this server and how does the signaling process actually work?</p>

<p>First we need the signaling server itself. WebRTC doesn't specify a transport mechanism for the signaling information. You can use anything you like, from <a href="../WebSockets_API-2.html">WebSocket</a> to <a href="../XMLHttpRequest.html" title="Use XMLHttpRequest (XHR) objects to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing."><code>XMLHttpRequest</code></a> to carrier pigeons to exchange the signaling information between the two peers.</p>

<p>It's important to note that the server doesn't need to understand or interpret the signaling data content. Although it's <a class="glossaryLink" href="https://developer.mozilla.org/en-US/docs/Glossary/SDP" title="SDP: SDP (Session Description Protocol) is the standard describing a peer-to-peer connection. SDP contains the codec, source address, and timing information of audio and video.">SDP</a>, even this doesn't matter so much: the content of the message going through the signaling server is, in effect, a black box. What does matter is when the <a class="glossaryLink" href="https://developer.mozilla.org/en-US/docs/Glossary/ICE" title="ICE: ICE (Interactive Connectivity Establishment) is a framework used by WebRTC (among other technologies) for connecting two peers to each other, regardless of network topology (usually for audio and/or video chat). This protocol lets two peers find and establish a connection with one another even though they may both be using Network Address Translator (NAT) to share a global IP address with other devices on their respective local networks.">ICE</a> subsystem instructs you to send signaling data to the other peer, you do so, and the other peer knows how to receive this information and deliver it to its own ICE subsystem. All you have to do is channel the information back and forth. The contents don't matter at all to the signaling server.</p>

<h3 id="Readying_the_chat_server_for_signaling">Readying the chat server for signaling</h3>

<p>Our <a class="external" href="https://github.com/mdn/samples-server/tree/master/s/websocket-chat" rel="noopener">chat server</a> uses the <a href="../WebSockets_API-2.html">WebSocket API</a> to send information as <a class="glossaryLink" href="https://developer.mozilla.org/en-US/docs/Glossary/JSON" title="JSON: JavaScript Object Notation&nbsp;(JSON) is a data-interchange format.&nbsp; Although not a strict subset, JSON closely resembles a subset of JavaScript syntax. Though many programming languages support JSON, JSON is especially useful for JavaScript-based apps, including websites and browser extensions.">JSON</a> strings between each client and the server. The server supports several message types to handle tasks, such as registering new users, setting usernames, and sending public chat messages.</p>

<p>To allow the server to support signaling and ICE negotiation, we need to update the code. We'll have to to allow directing messages to one specific user instead of broadcasting to all connected users, and ensure unrecognized message types are passed through and delivered, without the server needing to know what they are. This lets us send signaling messages using this same server, instead of needing a separate server.</p>

<p>Let's take a look which changes we need to make to the chat server support WebRTC signaling. This is in the file <a class="external" href="https://github.com/mdn/samples-server/tree/master/s/webrtc-from-chat/chatserver.js" rel="noopener">chatserver.js</a>.</p>

<p>First up is the addition of the function <code>sendToOneUser()</code>. As the name suggests, this sends a stringified JSON message to a particular username.</p>

<pre class="brush: js">function sendToOneUser(target, msgString) {
  var isUnique = true;
  var i;

  for (i=0; i&lt;connectionArray.length; i++) {
    if (connectionArray[i].username === target) {
      connectionArray[i].send(msgString);
      break;
    }
  }
}</pre>

<p>This function iterates over the list of connected users until it finds one matching the specified username, then sends the message to that user. The parameter <code>msgString</code> is a stringified JSON object. We could have made it receive our original message object, but in this example it's more efficient this way. Since the message has already been stringified, we can send it with no further processing. Each entry in <code>connectionArray</code> is a <a href="../WebSocket.html" title="The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."><code>WebSocket</code></a> object, so we can just call its <a href="../WebSocket/send.html" title="The WebSocket.send() method enqueues the specified data to be transmitted to the server over the WebSocket connection, increasing the value of bufferedAmount by the number of bytes needed to contain the data. If the data can't be sent (for example, because it needs to be buffered but the buffer is full), the socket is closed automatically."><code>send()</code></a> method directly.</p>

<p>Our original chat demo didn't support sending messages to a specific user. The next task is to update the main WebSocket message handler to support doing so. This involves a change near the end of the <code>"connection"</code> message handler:</p>

<pre class="brush: js">if (sendToClients) {
  var msgString = JSON.stringify(msg);
  var i;

  if (msg.target &amp;&amp; msg.target !== undefined &amp;&amp; msg.target.length !== 0) {
    sendToOneUser(msg.target, msgString);
  } else {
    for (i=0; i&lt;connectionArray.length; i++) {
      connectionArray[i].send(msgString);
    }
  }
}</pre>

<p>This code now looks at the pending message to see if it has a <code>target</code> property. If that property is present, it specifies the username of the client to which the message is to be sent, and we call <code>sendToOneUser()</code> to send the message to them. Otherwise, the message is broadcast to all users by iterating over the connection list, sending the message to each user.</p>

<p>As the existing code allows the sending of arbitrary message types, no additional changes are required. Our clients can now send messages of unknown types to any specific user, letting them send signaling messages back and forth as desired.</p>

<p>That's all we need to change on the server side of the equation. Now let's consider the signaling protocol we will implement.</p>

<h3 id="Designing_the_signaling_protocol">Designing the signaling protocol</h3>

<p>Now that we've built a mechanism for exchanging messages, we need a protocol defining how those messages will look. This can be done in a number of ways; what's demonstrated here is just one possible way to structure signaling messages.</p>

<p>This example's server uses stringified JSON objects to communicate with its clients. This means our signaling messages will be in JSON format, with contents which specify what kind of messages they are as well as any additional information needed in order to handle the messages properly.</p>

<h4 id="Exchanging_session_descriptions">Exchanging session descriptions</h4>

<p>When starting the signaling process, an <strong>offer</strong> is created by the user initiating the call. This offer includes a session description, in <a class="glossaryLink" href="https://developer.mozilla.org/en-US/docs/Glossary/SDP" title="SDP: SDP (Session Description Protocol) is the standard describing a peer-to-peer connection. SDP contains the codec, source address, and timing information of audio and video.">SDP</a> format, and needs to be delivered to the receiving user, which we'll call the <strong>callee</strong>. The callee responds to the offer with an <strong>answer</strong> message, also containing an SDP description. Our signaling server will use WebSocket to transmit offer messages with the type <code>"video-offer"</code>, and answer messages with the type <code>"video-answer"</code>. These messages have the following fields:</p>

<dl>
	<dt><code>type</code></dt>
	<dd>The message type; either <code>"video-offer"</code> or <code>"video-answer"</code>.</dd>
	<dt><code>name</code></dt>
	<dd>The sender's username.</dd>
	<dt><code>target</code></dt>
	<dd>The username of the person to receive the description (if the caller is sending the message, this specifies the callee, and vice-versa).</dd>
	<dt><code>sdp</code></dt>
	<dd>The SDP (Session Description Protocol) string describing the local end of the connection from the perspective of the sender (or the remote end of the connection from the receiver's point of view).</dd>
</dl>

<p>At this point, the two participants know which codecs and video parameters are to be used for this call. They still don't know how to transmit the media data itself though. This is where <a class="glossaryLink" href="https://developer.mozilla.org/en-US/docs/Glossary/ICE" title="Interactive Connectivity Establishment (ICE): ICE (Interactive Connectivity Establishment) is a framework used by WebRTC (among other technologies) for connecting two peers to each other, regardless of network topology (usually for audio and/or video chat). This protocol lets two peers find and establish a connection with one another even though they may both be using Network Address Translator (NAT) to share a global IP address with other devices on their respective local networks.">Interactive Connectivity Establishment (ICE)</a> comes in.</p>

<h3 id="Exchanging_ICE_candidates">Exchanging ICE candidates</h3>

<p>Two peers need to exchange ICE candidates to negotiate the actual connection between them. Every ICE candidate describes a method that the sending peer is able to use to communicate. Each peer sends candidates in the order they're discovered, and keeps sending candidates until it runs out of suggestions, even if media has already started streaming.</p>

<p>An <code>icecandidate</code> event is sent to the <a href="../RTCPeerConnection.html" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a> to complete the process of adding a local description using <code>pc.setLocalDescription(offer)</code>.</p>

<p>Once the two peers agree upon a mutually-compatible candidate, that candidate's SDP is used by each peer to construct and open a connection, through which media then begins to flow. If they later agree on a better (usually higher-performance) candidate, the stream may change formats as needed.</p>

<p>Though not currently supported, a candidate received after media is already flowing could theoretically also be used to downgrade to a lower-bandwidth connection if needed.</p>

<p>Each ICE candidate is sent to the other peer by sending a JSON message of type <code>"new-ice-candidate"</code> over the signaling server to the remote peer. Each candidate message include these fields:</p>

<dl>
	<dt><code>type</code></dt>
	<dd>The message type: <code>"new-ice-candidate"</code>.</dd>
	<dt><code>target</code></dt>
	<dd>The username of the person with whom negotiation is underway; the server will direct the message to this user only.</dd>
	<dt><code>candidate</code></dt>
	<dd>The SDP candidate string, describing the proposed connection method. You typically don't need to look at the contents of this string. All your code needs to do is route it through to the remote peer using the signaling server.</dd>
</dl>

<p>Each ICE message suggests a communication protocol (TCP or UDP), IP address, port number, connection type (for example, whether the specified IP is the peer itself or a relay server), along with other information needed to link the two computers together. This includes NAT or other networking complexity.</p>

<div class="note">
<p><strong>Note:</strong> The important thing to note is this: the only thing your code is responsible for during ICE negotiation is accepting outgoing candidates from the ICE layer and sending them across the signaling connection to the other peer when your <a href="../RTCPeerConnection/onicecandidate.html" title="The RTCPeerConnection.onicecandidate property is an EventHandler which specifies a function to be called when the icecandidate event occurs on an RTCPeerConnection instance. This happens whenever the local ICE agent needs to deliver a message to the other peer through the signaling server."><code>onicecandidate</code></a> handler is executed, and receiving ICE candidate messages from the signaling server (when the <code>"new-ice-candidate"</code> message is received) and delivering them to your ICE layer by calling <a href="../RTCPeerConnection/addIceCandidate.html" title="When a web site or app using RTCPeerConnection receives a new ICE candidate from the remote peer over its signaling channel, it delivers the newly-received candidate to the browser's ICE agent by calling RTCPeerConnection.addIceCandidate()."><code>RTCPeerConnection.addIceCandidate()</code></a>. That's it.</p>

<p>The contents of the SDP are irrelevant to you in essentially all cases. Avoid the temptation to try to make it more complicated than that until you really know what you're doing. That way lies madness.</p>
</div>

<p>All your signaling server now needs to do is send the messages it's asked to. Your workflow may also demand login/authentication functionality, but such details will vary.</p>

<h3 id="Signaling_transaction_flow">Signaling transaction flow</h3>

<p>The signaling process involves this exchange of messages between two peers using an intermediary, the signaling server. The exact process will vary, of course, but in general there are a few key points at which signaling messages get handled:</p>

<p>The signaling process involves this exchange of messages among a number of points:</p>

<ul>
	<li>Each user's client running within a web browser</li>
	<li>Each user's web browser</li>
	<li>The signaling server</li>
	<li>The web server hosting the chat service</li>
</ul>

<p>Imagine that Naomi and Priya are engaged in a discussion using the chat software, and Naomi decides to open a video call between the two. Here's the expected sequence of events:</p>

<p><a class="external" href="../../../../../../mdn.mozillademos.org/files/12363/WebRTC%20-%20Signaling%20Diagram.svg" rel="noopener"><img alt="Diagram of the signaling process" src="../../../../../../mdn.mozillademos.org/files/16137/WebRTC_-_Signaling_Diagram.svg" style="height: 1117px; width: 901px;"></a></p>

<p>We'll see this detailed more over the course of this article.</p>

<h3 id="ICE_candidate_exchange_process">ICE candidate exchange process</h3>

<p>When each peer's ICE layer begins to send candidates, it enters into an exchange among the various points in the chain that looks like this:</p>

<p><a class="external" href="../../../../../../mdn.mozillademos.org/files/12365/WebRTC%20-%20ICE%20Candidate%20Exchange.svg" rel="noopener"><img alt="Diagram of ICE candidate exchange process" src="../../../../../../mdn.mozillademos.org/files/12365/WebRTC%20-%20ICE%20Candidate%20Exchange.svg" style="height: 590px; width: 700px;"></a></p>

<p>Each side sends candidates to the other as it receives them from their local ICE layer; there is no taking turns or batching of candidates. As soon as the two peers agree upon one candidate that they can both use to exchange the media, media begins to flow. Each peer continues to send candidates until it runs out of options, even after the media has already begun to flow. This is done in hopes of identifying even better options than the one initially selected.</p>

<p>If conditions change—for example the network connection deteriorates—one or both peers might suggest switching to a lower-bandwidth media resolution, or to an alternative codec. This triggers a new exchange of candidates, after which a another media format and/or codec change may take place.</p>

<p>Optionally, see <a class="external" href="https://tools.ietf.org/html/rfc5245" rel="noopener">RFC 5245: Interactive Connectivity Establishment</a>, <a class="external" href="https://tools.ietf.org/html/rfc5245#section-2.6" rel="noopener">section 2.6 ("Concluding ICE")</a> if you want greater understanding of this process is completed inside the ICE layer. You should note that candidates are exchanged and media starts to flow as soon as the ICE layer is satisfied. This all taken care of behind the scenes. Our role is to simply send the candidates, back and forth, through the signaling server.</p>

<a class="dashAnchor" name="//apple_ref/Section/The%20client%20application"></a><h2 id="The_client_application">The client application</h2>

<p>The core to any signaling process is its message handling. It's not necessary to use WebSockets for signaling, but it is a common solution. You should, of course, select a mechanism for exchanging signaling information that is appropriate for your application.</p>

<p>Let's update the chat client to support video calling.</p>

<h3 id="Updating_the_HTML">Updating the HTML</h3>

<p>The HTML for our client needs a location for video to be presented. This requires video elements, and a button to hang up the call:</p>

<pre class="brush: html">&lt;div class="flexChild" id="camera-container"&gt;
  &lt;div class="camera-box"&gt;
    &lt;video id="received_video" autoplay&gt;&lt;/video&gt;
    &lt;video id="local_video" autoplay muted&gt;&lt;/video&gt;
    &lt;button id="hangup-button" onclick="hangUpCall();" disabled&gt;
      Hang Up
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>

<p>The page structure defined here is using <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div" title="The HTML Content Division element (<div>) is the generic container for flow content. It has no effect on the content or layout until styled using CSS."><code>&lt;div&gt;</code></a> elements, giving us full control over the page layout by enabling the use of CSS. We'll skip layout detail in this guide, but <a class="external" href="https://github.com/mdn/samples-server/tree/master/s/webrtc-from-chat/chat.css" rel="noopener">take a look at the CSS</a> on Github to see how we handled it. Take note of the two <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video" title="The HTML Video element (<video>) embeds a media player which supports video playback into the document."><code>&lt;video&gt;</code></a> elements, one for your self-view, one for the connection, and the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button" title="The HTML <button> element represents a clickable button, which can be used in forms or anywhere in a document that needs simple, standard button functionality."><code>&lt;button&gt;</code></a> element.</p>

<p>The <code>&lt;video&gt;</code> element with the <code>id</code> "<code>received_video</code>" will present video received from the connected user. We specify the <code>autoplay</code> attribute, ensuring once the video starts arriving, it immediately plays. This removes any need to explicitly handle playback in our code. The "<code>local_video</code>" <code>&lt;video&gt;</code> element presents a preview of the user's camera; specifiying the <code>muted</code> attribute, as we don't need to hear local audio in this preview panel.</p>

<p>Finally, the "<code>hangup-button</code>" <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button" title="The HTML <button> element represents a clickable button, which can be used in forms or anywhere in a document that needs simple, standard button functionality."><code>&lt;button&gt;</code></a>, to disconnect from a call, is defined and configured to start disabled (setting this as our default for when no call is connected) and apply the function <code>hangUpCall()</code> on click. This function's role is to close the call, and send a signalling server notification to the other peer, requesting it also close.</p>

<h3 id="The_JavaScript_code">The JavaScript code</h3>

<p>We'll divide this code into functional areas to more easily describe how it works. The main body of this code is found in the <code>connect()</code> function: it opens up a <a href="../WebSocket.html" title="The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."><code>WebSocket</code></a> server on port 6503, and establishes a handler to receive messages in JSON object format. This code generally handles text chat messages as it did previously.</p>

<h4 id="Sending_messages_to_the_signaling_server">Sending messages to the signaling server</h4>

<p>Throughout our code, we call <code>sendToServer()</code> in order to send messages to the signaling server. This function uses the <a href="../WebSockets_API-2.html">WebSocket</a> connection to do its work:</p>

<pre class="brush: js">function sendToServer(msg) {
  var msgJSON = JSON.stringify(msg);

  connection.send(msgJSON);
}</pre>

<p>The message object passed into this function is converted into a JSON string by calling <a href="../../JavaScript/Reference/Global_Objects/JSON/stringify.html" title="The JSON.stringify() method converts a JavaScript object or value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified."><code>JSON.stringify()</code></a>, then we call the WebSocket connection's <a href="../WebSocket/send.html" title="The WebSocket.send() method enqueues the specified data to be transmitted to the server over the WebSocket connection, increasing the value of bufferedAmount by the number of bytes needed to contain the data. If the data can't be sent (for example, because it needs to be buffered but the buffer is full), the socket is closed automatically."><code>send()</code></a> function to transmit the message to the server.</p>

<h4 id="UI_to_start_a_call">UI to start a call</h4>

<p>The code which handles the <code>"userlist"</code> message calls <code>handleUserlistMsg()</code>. Here we set up the handler for each connected user in the user list displayed to the left of the chat panel. This function receives a message object whose <code>users</code> property is an array of strings specifying the user names of every connected user.</p>

<pre class="brush: js">function handleUserlistMsg(msg) {
  var i;
  var listElem = document.querySelector(".userlistbox");

  while (listElem.firstChild) {
    listElem.removeChild(listElem.firstChild);
  }

  msg.users.forEach(function(username) {
    var item = document.createElement("li");
    item.appendChild(document.createTextNode(username));
    item.addEventListener("click", invite, false);

    listElem.appendChild(item);
  });
}</pre>

<p>After getting a reference to the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul" title="The HTML <ul> element represents an unordered list of items, typically rendered as a bulleted list."><code>&lt;ul&gt;</code></a> which contains the list of user names into the variable <code>listElem</code>, we empty the list by removing each of its child elements.</p>

<div class="note">
<p><strong>Note:</strong> Obviously, it would be more efficient to update the list by adding and removing individual users instead of rebuilding the whole list every time it changes, but this is good enough for the purposes of this example.</p>
</div>

<p>Then we iterate over the array of user names using <a href="../../JavaScript/Reference/Global_Objects/Array/forEach.html" title="The forEach() method executes a provided function once for each array element."><code>forEach()</code></a>. For each name, we create a new <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li" title="The HTML <li> element is used to represent an item in a list. It must be contained in a parent element: an ordered list (<ol>), an unordered list (<ul>), or a menu (<menu>). In menus and unordered lists, list items are usually displayed using bullet points. In ordered lists, they are usually displayed with an ascending counter on the left, such as a number or letter."><code>&lt;li&gt;</code></a> element, then create a new text node containing the user name using <a href="../Document/createTextNode.html" title="Creates a new Text node. This method can be used to escape HTML characters."><code>createTextNode()</code></a>. That text node is added as a child of the <code>&lt;li&gt;</code> element. Next, we set a handler for the <code><a href="../Element/click_event.html" title="/en-US/docs/Web/Events/click">click</a></code> event on the list item, that clicking on a user name calls our <code>invite()</code> method, which we'll look at in the next section.</p>

<p>Finally, we append the new item to the <code>&lt;ul&gt;</code> that contains all of the user names.</p>

<h4 id="Starting_a_call">Starting a call</h4>

<p>When the user clicks on a username they want to call, the <code>invite()</code> function is invoked as the event handler for that <code><a href="../Element/click_event.html" title="/en-US/docs/Web/Events/click">click</a></code> event:</p>

<pre class="brush: js">var mediaConstraints = {
  audio: true, // We want an audio track
  video: true // ...and we want a video track
};

function invite(evt) {
  if (myPeerConnection) {
    alert("You can't start a call because you already have one open!");
  } else {
    var clickedUsername = evt.target.textContent;

    if (clickedUsername === myUsername) {
      alert("I'm afraid I can't let you talk to yourself. That would be weird.");
      return;
    }

    targetUsername = clickedUsername;
    createPeerConnection();

    navigator.mediaDevices.getUserMedia(mediaConstraints)
    .then(function(localStream) {
      document.getElementById("local_video").srcObject = localStream;
      localStream.getTracks().forEach(track =&gt; myPeerConnection.addTrack(track, localStream));
    })
    .catch(handleGetUserMediaError);
  }
}</pre>

<p>This begins with a basic sanity check: is the user even connected? If there's no <a href="../RTCPeerConnection.html" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a>, they obviously can't make a call. Then the name of the user that was clicked upon is obtained from the event target's <a href="../Node/textContent.html" title="The textContent property of the Node interface represents the text content of a node and its descendants."><code>textContent</code></a> property, and we check to be sure that it's not the same user that's trying to start the call.</p>

<p>Then we copy the name of the user we're calling into the variable <code>targetUsername</code> and call <code>createPeerConnection()</code>, a function which will create and do basic configuration of the <a href="../RTCPeerConnection.html" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a>.</p>

<p>Once the <code>RTCPeerConnection</code> has been created, we request access to the user's camera and microphone by calling <a href="../MediaDevices/getUserMedia.html" title="The MediaDevices.getUserMedia() method prompts the user for permission to use a media input which produces a MediaStream with tracks containing the requested types of media."><code>MediaDevices.getUserMedia()</code></a>, which is exposed to us through the <a href="../MediaDevices/getUserMedia.html" title="REDIRECT MediaDevices.getUserMedia()"><code>Navigator.mediaDevices.getUserMedia</code></a> property. When this succeeds, fulfilling the returned promise, our <code>then</code> handler is executed. It receives, as input, a <a href="../MediaStream.html" title="The MediaStream interface represents a stream of media content. A stream consists of several tracks such as&nbsp;video or audio tracks. Each track is specified as an instance of MediaStreamTrack."><code>MediaStream</code></a> object representing the stream with audio from the user's microphone and video from their webcam.</p>

<div class="note">
<p><strong>Note:</strong> We could restrict the set of permitted media inputs to a specific device or set of devices by calling <a href="../MediaDevices/enumerateDevices.html" title="The MediaDevices method enumerateDevices() requests a list of the available media input and output devices, such as microphones, cameras, headsets, and so forth."><code>navigator.mediaDevices.enumerateDevices()</code></a> to get a list of devices, filtering the resulting list based on our desired criteria, then using the selected devices' <a href="../MediaTrackConstraints/deviceId.html" title="The MediaTrackConstraints dictionary's deviceId property is a ConstrainDOMString describing the requested or mandatory constraints placed upon the value of the deviceId constrainable property."><code>deviceId</code></a> values in the <code>deviceId</code> field of the the <code>mediaConstraints</code> object passed into <code>getUserMedia()</code>. In practice, this is rarely if ever necessary, since most of that work is done for you by <code>getUserMedia()</code>.</p>
</div>

<p>We attach the incoming stream to the local preview <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video" title="The HTML Video element (<video>) embeds a media player which supports video playback into the document."><code>&lt;video&gt;</code></a> element by setting the element's <a href="../HTMLMediaElement/srcObject.html" title="The srcObject&nbsp;property of the HTMLMediaElement interface sets or returns the object which serves as the source of the media associated with the HTMLMediaElement."><code>srcObject</code></a> property. Since the element is configured to automatically play incoming video, the stream begins playing in our local preview box.</p>

<p>We then iterate over the tracks in the stream, calling <a href="../RTCPeerConnection/addTrack.html" title="The RTCPeerConnection method addTrack() adds a new media track to the set of tracks which will be transmitted to the other peer."><code>addTrack()</code></a> to add each track to the <code>RTCPeerConnection</code>. Even though the connection is not fully established yet, it's important to begin sending media to it as soon as possible, because the media will help the ICE layer decide on the best connectivity approach to take, aiding in the negotiation process.</p>

<p>As soon as media is attached to the <code>RTCPeerConnection</code>, a <code><a href="../RTCPeerConnection/negotiationneeded_event.html" title="/en-US/docs/Web/Events/negotiationneeded">negotiationneeded</a></code> event is triggered at the connection, so that ICE negotiation can be started.</p>

<p>If an error occurs while trying to get the local media stream, our catch clause calls <code>handleGetUserMediaError()</code>, which displays an appropriate error to the user as required.</p>

<h4 id="Handling_getUserMedia()_errors">Handling getUserMedia() errors</h4>

<p>If the promise returned by <code>getUserMedia()</code> concludes in a failure, our <code>handleGetUserMediaError()</code> function performs.</p>

<pre class="brush: js">function handleGetUserMediaError(e) {
  switch(e.name) {
    case "NotFoundError":
      alert("Unable to open your call because no camera and/or microphone" +
            "were found.");
      break;
    case "SecurityError":
    case "PermissionDeniedError":
      // Do nothing; this is the same as the user canceling the call.
      break;
    default:
      alert("Error opening your camera and/or microphone: " + e.message);
      break;
  }

  closeVideoCall();
}</pre>

<p>An error message is displayed in all cases but one. In this example, we ignore <code>"SecurityError"</code> and <code>"PermissionDeniedError"</code> results, treating refusal to grant permission to use the media hardware the same as the user canceling the call.</p>

<p>Regardless of why an attempt to get the stream fails, we call our <code>closeVideoCall()</code> function to shut down the <a href="../RTCPeerConnection.html" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a>, and release any resources already allocated by the process of attempting the call. This code is designed to safely handle partially-started calls.</p>

<h4 id="Creating_the_peer_connection">Creating the peer connection</h4>

<p>The <code>createPeerConnection()</code> function is used by both the caller and the callee to construct their <a href="../RTCPeerConnection.html" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a> objects, their respective ends of the WebRTC connection. It's invoked by <code>invite()</code> when the caller tries to start a call, and by <code>handleVideoOfferMsg()</code> when the callee receives an offer message from the caller.</p>

<pre class="brush: js">function createPeerConnection() {
  myPeerConnection = new RTCPeerConnection({
      iceServers: [     // Information about ICE servers - Use your own!
        {
          urls: "stun:stun.stunprotocol.org"
        }
      ]
  });

  myPeerConnection.onicecandidate = handleICECandidateEvent;
&nbsp; myPeerConnection.ontrack = handleTrackEvent;
&nbsp; myPeerConnection.onnegotiationneeded = handleNegotiationNeededEvent;
&nbsp; myPeerConnection.onremovetrack = handleRemoveTrackEvent;
&nbsp; myPeerConnection.oniceconnectionstatechange = handleICEConnectionStateChangeEvent;
&nbsp; myPeerConnection.onicegatheringstatechange = handleICEGatheringStateChangeEvent;
&nbsp; myPeerConnection.onsignalingstatechange = handleSignalingStateChangeEvent;
}
</pre>

<p>When using the <a href="../RTCPeerConnection/RTCPeerConnection.html" title="The RTCPeerConnection() constructor returns a newly-created RTCPeerConnection, which represents a connection between the local device and a remote peer."><code>RTCPeerConnection()</code></a> constructor, we will specify an <a href="../RTCConfiguration.html" title="The RTCConfiguration dictionary is used to provide configuration options for an RTCPeerConnection. It may be passed into the constructor when instantiating a connection, or used with the RTCPeerConnection.getConfiguration() and RTCPeerConnection.setConfiguration() methods, which allow inspecting and changing the configuration while a connection is established."><code>RTCConfiguration</code></a>-compliant object providing configuration parameters for the connection. We use only one of these in this example: <code>iceServers</code>. This is an array of objects describing STUN and/or TURN servers for the <a class="glossaryLink" href="https://developer.mozilla.org/en-US/docs/Glossary/ICE" title="ICE: ICE (Interactive Connectivity Establishment) is a framework used by WebRTC (among other technologies) for connecting two peers to each other, regardless of network topology (usually for audio and/or video chat). This protocol lets two peers find and establish a connection with one another even though they may both be using Network Address Translator (NAT) to share a global IP address with other devices on their respective local networks.">ICE</a> layer to use when attempting to establish a route between the caller and the callee. These servers are used to determine the best route and protocols to use when communicating between the peers, even if they're behind a firewall or using <a class="glossaryLink" href="https://developer.mozilla.org/en-US/docs/Glossary/NAT" title="NAT: NAT (Network Address Translation) is a technique for letting multiple computers share an IP address. NAT assigns unique addresses to each computer on the local network and adjusts incoming/outgoing network traffic to send data to the right place.">NAT</a>.</p>

<div class="note">
<p><strong>Note:</strong> You should always use STUN/TURN servers which you own, or which you have specific authorization to use. This example is using a known public STUN server but abusing these is bad form.</p>
</div>

<p>Each object in <code>iceServers</code> contains at least a <code>urls</code> field providing URLs at which the specified server can be reached. It may also provide <code>username</code> and <code>credential</code> values to allow authentication to take place, if needed.</p>

<p>After creating the <a href="../RTCPeerConnection.html" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a>, we set up handlers for the events that matter to us.</p>

<p>The first three of these event handlers are required; you have to handle them to do anything involving streamed media with WebRTC. The rest aren't strictly required but can be useful, and we'll explore them. There are a few other events available that we're not using in this example, as well. Here's a summary of each of the event handlers we will be implementing:</p>

<dl>
	<dt><a href="../RTCPeerConnection/onicecandidate.html" title="The RTCPeerConnection.onicecandidate property is an EventHandler which specifies a function to be called when the icecandidate event occurs on an RTCPeerConnection instance. This happens whenever the local ICE agent needs to deliver a message to the other peer through the signaling server."><code>RTCPeerConnection.onicecandidate</code></a></dt>
	<dd>The local ICE layer calls your <code><a href="../RTCPeerConnection/icecandidate_event.html" title="/en-US/docs/Web/Events/icecandidate">icecandidate</a></code> event handler, when it needs you to transmit an ICE candidate to the other peer, through your signaling server. See <a href="#Sending_ICE_candidates">Sending ICE candidates</a> for more information and to see the code for this example.</dd>
	<dt><a href="../RTCPeerConnection/ontrack.html" title="The RTCPeerConnection property ontrack is an EventHandler which specifies a function to be called when the track event occurs, indicating that a track has been added to the RTCPeerConnection."><code>RTCPeerConnection.ontrack</code></a></dt>
	<dd>This handler for the <code><a href="../RTCPeerConnection/track_event.html" title="/en-US/docs/Web/Events/track">track</a></code> event is called by the local WebRTC layer when a track is added to the connection. This lets you connect the incoming media to an element to display it, for example. See <a href="#Receiving_new_streams">Receiving new streams</a> for details.</dd>
	<dt><a href="../RTCPeerConnection/onnegotiationneeded.html" title="The RTCPeerConnection.onnegotiationneeded property is an EventHandler which specifies a function which is called to handle the negotiationneeded event when it occurs on an RTCPeerConnection instance. This event is fired when a change has occurred which requires session negotiation. This negotiation should be carried out as the offerer, because some session changes cannot be negotiated as the answerer."><code>RTCPeerConnection.onnegotiationneeded</code></a></dt>
	<dd>This function is called whenever the WebRTC infrastructure needs you to start the session negotiation process anew. Its job is to create and send an offer, to the callee, asking it to connect with us. See <a href="#Starting_negotiation">Starting negotiation</a> to see how we handle this.</dd>
	<dt><a class="new" href="../RTCPeerConnection/onremovetrack.html" rel="nofollow" title="The documentation about this has not yet been written; please consider contributing!"><code>RTCPeerConnection.onremovetrack</code></a></dt>
	<dd>This counterpart to <code>ontrack</code> is called to handle the <code><a href="../VideoTrackList/removetrack_event.html" title="/en-US/docs/Web/Events/removetrack">removetrack</a></code> event; it's sent to the <code>RTCPeerConnection</code> when the remote peer removes a track from the media being sent. See <a href="#Handling_the_removal_of_tracks">Handling the removal of tracks</a>.</dd>
	<dt><a href="../RTCPeerConnection/oniceconnectionstatechange.html" title="The RTCPeerConnection.oniceconnectionstatechange property is an event handler which specifies a function to be called when the iceconnectionstatechange event is fired on an RTCPeerConnection instance. This happens when the state of the connection's ICE agent, as represented by the iceConnectionState property, changes."><code>RTCPeerConnection.oniceconnectionstatechange</code></a></dt>
	<dd>The <code><a href="../RTCPeerConnection/iceconnectionstatechange_event.html" title="/en-US/docs/Web/Events/iceconnectionstatechange">iceconnectionstatechange</a></code> event is sent by the ICE layer to let you know about changes to the state of the ICE connection. This can help you know when the connection has failed, or been lost. We'll look at the code for this example in <a href="#ICE_connection_state">ICE connection state</a> below.</dd>
	<dt><a href="../RTCPeerConnection/onicegatheringstatechange.html" title="The RTCPeerConnection.onicegatheringstatechange property is an EventHandler which specifies a function to be called when the icegatheringstatechange event is sent to an RTCPeerConnection instance. This happens when the ICE gathering state—that is, whether or not the ICE agent is actively gathering candidates—changes."><code>RTCPeerConnection.onicegatheringstatechange</code></a></dt>
	<dd>The ICE layer sends you the <code><a href="../RTCPeerConnection/icegatheringstatechange_event.html" title="/en-US/docs/Web/Events/icegatheringstatechange">icegatheringstatechange</a></code> event, when the ICE agent's process of collecting candidates shifts, from one state to another (such as starting to gather candidates or completing negotiation). See <a href="#ICE_gathering_state">ICE gathering state</a> below.</dd>
	<dt><a href="../RTCPeerConnection/onsignalingstatechange.html" title="The onsignalingstatechange property of the RTCPeerConnection interface is an EventHandler which specifies a function to be called when the signalingstatechange event occurs on an RTCPeerConnection interface."><code>RTCPeerConnection.onsignalingstatechange</code></a></dt>
	<dd>The WebRTC infrastructure sends you the <code><a href="../RTCPeerConnection/signalingstatechange_event.html" title="/en-US/docs/Web/Events/signalingstatechange">signalingstatechange</a></code> message when the state of the signaling process changes (or if the connection to the signaling server changes). See <a href="#Signaling_state">Signaling state</a> to see our code.</dd>
</dl>

<h4 id="Starting_negotiation">Starting negotiation</h4>

<p>Once the caller has created its&nbsp; <a href="../RTCPeerConnection.html" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a>, created a media stream, and added its tracks to the connection as shown in <a href="#Starting_a_call">Starting a call</a>, the browser will deliver a <code><a href="../RTCPeerConnection/negotiationneeded_event.html" title="/en-US/docs/Web/Events/negotiationneeded">negotiationneeded</a></code> event to the <a href="../RTCPeerConnection.html" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a> to indicate that it's ready to begin negotiation with the other peer. Here's our code for handling the <code><a href="../RTCPeerConnection/negotiationneeded_event.html" title="/en-US/docs/Web/Events/negotiationneeded">negotiationneeded</a></code> event:</p>

<pre class="brush: js">function handleNegotiationNeededEvent() {
  myPeerConnection.createOffer().then(function(offer) {
    return myPeerConnection.setLocalDescription(offer);
  })
  .then(function() {
    sendToServer({
      name: myUsername,
      target: targetUsername,
      type: "video-offer",
      sdp: myPeerConnection.localDescription
    });
  })
  .catch(reportError);
}</pre>

<p>To start the negotiation process, we need to create and send an SDP offer to the peer we want to connect to. This offer includes a list of supported configurations for the connection, including information about the media stream we've added to the connection locally (that is, the video we want to send to the other end of the call), and any ICE candidates gathered by the ICE layer already. We create this offer by calling <a href="../RTCPeerConnection/createOffer.html" title="The createOffer() method of the RTCPeerConnection interface initiates the creation of an SDP offer for the purpose of starting a new WebRTC connection to a remote peer."><code>myPeerConnection.createOffer()</code></a>.</p>

<p>When <code>createOffer()</code> succeeds (fulfilling the promise), we pass the created offer information into <a href="../RTCPeerConnection/setLocalDescription.html" title="The RTCPeerConnection.setLocalDescription() method changes the local description associated with the connection. This description specifies the properties of the local end of the connection, including the media format."><code>myPeerConnection.setLocalDescription()</code></a>, which configures the connection and media configuration state for the caller's end of the connection.</p>

<div class="note">
<p><strong>Note:</strong> Technically speaking, the string returned by <code>createOffer()</code> is an <a class="external" href="https://tools.ietf.org/html/rfc3264" rel="noopener">RFC 3264</a> offer.</p>
</div>

<p>We know the description is valid, and has been set, when the promise returned by <code>setLocalDescription()</code> is fulfilled. This is when we send our offer to the other peer by creating a new <code>"video-offer"</code> message containing the local description (now the same as the offer), then sending it through our signaling server to the callee. The offer has the following members:</p>

<dl>
	<dt><code>type</code></dt>
	<dd>The message type: <code>"video-offer"</code>.</dd>
	<dt><code>name</code></dt>
	<dd>The caller's username.</dd>
	<dt><code>target</code></dt>
	<dd>The name of the user we wish to call.</dd>
	<dt><code>sdp</code></dt>
	<dd>The SDP string describing the offer.</dd>
</dl>

<p>If an error occurs, either in the initial <code>createOffer()</code> or in any of the fulfillment handlers that follow, an error is reported by invoking our <code>reportError()</code> function.</p>

<p>Once <code>setLocalDescription()</code>'s fulfillment handler has run, the ICE agent begins sending <code><a href="../RTCPeerConnection/icecandidate_event.html" title="/en-US/docs/Web/Events/icecandidate">icecandidate</a></code> events to the <a href="../RTCPeerConnection.html" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a>, one for each potential configuration it discovers. Our handler for the <code>icecandidate</code> event is responsible for transmitting the candidates to the other peer.</p>

<h4 id="Session_negotiation">Session negotiation</h4>

<p>Now that we've started negotiation with the other peer and have transmitted an offer, let's look at what happens on the callee's side of the connection for a while. The callee receives the offer and calls <code>handleVideoOfferMsg()</code> function to process it. Let's see how the callee handles the <code>"video-offer"</code> message.</p>

<h5 id="Handling_the_invitation">Handling the invitation</h5>

<p>When the offer arrives, the callee's <code>handleVideoOfferMsg()</code> function is called with the <code>"video-offer"</code> message that was received. This function needs to do two things. First, it needs to create its own <a href="../RTCPeerConnection.html" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a> and add the tracks containing the audio and video from its microphone and webcam to that. Second, it needs to process the received offer, constructing and sending its answer.</p>

<pre class="brush: js">function handleVideoOfferMsg(msg) {
  var localStream = null;

  targetUsername = msg.name;
  createPeerConnection();

  var desc = new RTCSessionDescription(msg.sdp);

  myPeerConnection.setRemoteDescription(desc).then(function () {
    return navigator.mediaDevices.getUserMedia(mediaConstraints);
  })
  .then(function(stream) {
    localStream = stream;
    document.getElementById("local_video").srcObject = localStream;

    localStream.getTracks().forEach(track =&gt; myPeerConnection.addTrack(track, localStream));
  })
  .then(function() {
    return myPeerConnection.createAnswer();
  })
  .then(function(answer) {
    return myPeerConnection.setLocalDescription(answer);
  })
  .then(function() {
    var msg = {
      name: myUsername,
      target: targetUsername,
      type: "video-answer",
      sdp: myPeerConnection.localDescription
    };

    sendToServer(msg);
  })
  .catch(handleGetUserMediaError);
}</pre>

<p class="brush: js">This code is very similar to what we did in the <code>invite()</code> function back in <a href="#Starting_a_call">Starting a call</a>. It starts by creating and configuring an <a href="../RTCPeerConnection.html" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a> using our <code>createPeerConnection()</code> function. Then it takes the SDP offer from the received <code>"video-offer"</code> message and uses it to create a new <a href="../RTCSessionDescription.html" title="The RTCSessionDescription interface describes one end of a connection—or potential connection—and how it's configured. Each RTCSessionDescription consists of a description type indicating which part of the offer/answer negotiation process it describes and of the SDP descriptor of the session."><code>RTCSessionDescription</code></a> object representing the caller's session description.</p>

<p class="brush: js">That session description is then passed into <a href="../RTCPeerConnection/setRemoteDescription.html" title="The RTCPeerConnection.setRemoteDescription() method changes the remote description associated with the connection. This description specifies the properties of the remote end of the connection, including the media format."><code>myPeerConnection.setRemoteDescription()</code></a>. This establishes the received offer as the description of the remote (caller's) end of the connection. If this is successful, the promise fulfillment handler (in the <code>then()</code> clause) starts the process of getting access to the callee's camera and microphone using <a href="../MediaDevices/getUserMedia.html" title="The MediaDevices.getUserMedia() method prompts the user for permission to use a media input which produces a MediaStream with tracks containing the requested types of media."><code>getUserMedia()</code></a>, adding the tracks to the connection, and so forth, as we saw previously in <code>invite()</code>.</p>

<p class="brush: js">Once the answer has been created using <a href="../RTCPeerConnection/createAnswer.html" title="The createAnswer() method on the RTCPeerConnection interface creates an SDP answer to an offer received from a remote peer during the offer/answer negotiation of a WebRTC connection. The answer contains information about any media already attached to the session, codecs and options supported by the browser, and any ICE candidates already gathered. The answer is delivered to the returned Promise, and should then be sent to the source of the offer to continue the negotiation process."><code>myPeerConnection.createAnswer()</code></a>, the description of the local end of the connection is set to the answer's SDP by calling <a href="../RTCPeerConnection/setLocalDescription.html" title="The RTCPeerConnection.setLocalDescription() method changes the local description associated with the connection. This description specifies the properties of the local end of the connection, including the media format."><code>myPeerConnection.setLocalDescription()</code></a>, then the answer is transmitted through the signaling server to the caller to let them know what the answer is</p>

<p>Any errors are caught and passed to <code>handleGetUserMediaError()</code>, described in <a href="#Handling_getUserMedia()_errors">Handling getUserMedia() errors</a>.</p>

<div class="note">
<p><strong>Note:</strong> As is the case with the caller, once the <code>setLocalDescription()</code> fulfillment handler has run, the browser begins firing <code><a href="../RTCPeerConnection/icecandidate_event.html" title="/en-US/docs/Web/Events/icecandidate">icecandidate</a></code> events that the callee must handle, one for each candidate that needs to be transmitted to the remote peer.</p>
</div>

<h5 id="Sending_ICE_candidates">Sending ICE candidates</h5>

<p>The ICE negotiation process involves each peer sending candidates to the other, repeatedly, until it runs out of potential ways it can support the <code>RTCPeerConnection</code>'s media transport needs. Since ICE doesn't know about your signaling server, your code&nbsp;handles transmission of each candidate in your handler for the <code><a href="../RTCPeerConnection/icecandidate_event.html" title="/en-US/docs/Web/Events/icecandidate">icecandidate</a></code> event.</p>

<p>Your <a href="../RTCPeerConnection/onicecandidate.html" title="The RTCPeerConnection.onicecandidate property is an EventHandler which specifies a function to be called when the icecandidate event occurs on an RTCPeerConnection instance. This happens whenever the local ICE agent needs to deliver a message to the other peer through the signaling server."><code>onicecandidate</code></a> handler receives an event whose <code>candidate</code> property is the SDP describing the candidate (or is <code>null</code> to indicate that the ICE layer has run out of potential configurations to suggest). The contents of <code>candidate</code> are what you need to transmit using your signaling server. Here's our example's implementation:</p>

<pre class="brush: js">function handleICECandidateEvent(event) {
  if (event.candidate) {
    sendToServer({
      type: "new-ice-candidate",
      target: targetUsername,
      candidate: event.candidate
    });
  }
}</pre>

<p>This builds an object containing the candidate, then sends it to the other peer using the <code>sendToServer()</code> function previously described in <a href="#Sending_messages_to_the_signaling_server">Sending messages to the signaling server</a>. The message's properties are:</p>

<dl>
	<dt><code>type</code></dt>
	<dd>The message type: <code>"new-ice-candidate"</code>.</dd>
	<dt><code>target</code></dt>
	<dd>The username the ICE candidate needs to be delivered to. This lets the signaling server route the message.</dd>
	<dt><code>candidate</code></dt>
	<dd>The SDP representing the candidate the ICE layer wants to transmit to the other peer.</dd>
</dl>

<p>The format of this message (as is the case with everything you do when handling signaling) is entirely up to you, depending on your needs; you can provide other information as required.</p>

<div class="note">
<p><strong>Note:</strong> It's important to keep in mind that the <code><a href="../RTCPeerConnection/icecandidate_event.html" title="/en-US/docs/Web/Events/icecandidate">icecandidate</a></code> event is <strong>not</strong> sent when ICE candidates arrive from the other end of the call. Instead, they're sent by your own end of the call so that you can take on the job of transmitting the data over whatever channel you choose. This can be confusing when you're new to WebRTC.</p>
</div>

<h5 id="Receiving_ICE_candidates">Receiving ICE candidates</h5>

<p>The signaling server delivers each ICE candidate to the destination peer using whatever method it chooses; in our example this is as JSON objects, with a <code>type</code> property containing the string <code>"new-ice-candidate"</code>. Our <code>handleNewICECandidateMsg()</code> function is called by our main <a href="../WebSockets_API-2.html">WebSocket</a> incoming message code to handle these messages:</p>

<pre class="brush: js">function handleNewICECandidateMsg(msg) {
  var candidate = new RTCIceCandidate(msg.candidate);

  myPeerConnection.addIceCandidate(candidate)
    .catch(reportError);
}</pre>

<p>This function constructs an <a href="../RTCIceCandidate.html" title="The RTCIceCandidate interface—part of the WebRTC API—represents a candidate Internet Connectivity Establishment (ICE) configuration which may be used to establish an RTCPeerConnection."><code>RTCIceCandidate</code></a> object by passing the received SDP into its constructor, then delivers the candidate to the ICE layer by passing it into <a href="../RTCPeerConnection/addIceCandidate.html" title="When a web site or app using RTCPeerConnection receives a new ICE candidate from the remote peer over its signaling channel, it delivers the newly-received candidate to the browser's ICE agent by calling RTCPeerConnection.addIceCandidate()."><code>myPeerConnection.addIceCandidate()</code></a>. This hands the fresh ICE candidate to the local ICE layer, and finally, our role in the process of handling this candidate is complete.</p>

<p>Each peer sends to the other peer a candidate for each possible transport configuration that it believes might be viable for the media being exchanged. At some point, the two peers agree that a given candidate is a good choice and they open the connection and begin to share media. It's important to note, however, that ICE negotiation does <em>not</em> stop once media is flowing. Instead, candidates may still keep being exchanged after the conversation has begun, either while trying to find a better connection method, or simply because they were already in transport when the peers successfully established their connection.</p>

<p>In addition, if something happens to cause a change in the streaming scenario, negotiation will begin again, with the <code><a href="../RTCPeerConnection/negotiationneeded_event.html" title="/en-US/docs/Web/Events/negotiationneeded">negotiationneeded</a></code> event being sent to the <a href="../RTCPeerConnection.html" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a>, and the entire process starts again as described before. This can happen in a variety of situations, including:</p>

<ul>
	<li>Changes in the network status, such as a bandwidth change, transitioning from WiFi to cellular connectivity, or the like.</li>
	<li>Switching between the front and rear cameras on a phone.</li>
	<li>A change to the configuration of the stream, such as its resolution or frame rate.</li>
</ul>

<h5 id="Receiving_new_streams">Receiving new streams</h5>

<p>When new tracks are added to the <code>RTCPeerConnection</code>— either by calling its <a href="../RTCPeerConnection/addTrack.html" title="The RTCPeerConnection method addTrack() adds a new media track to the set of tracks which will be transmitted to the other peer."><code>addTrack()</code></a> method or because of renegotiation of the stream's format—a <code><a href="../RTCPeerConnection/track_event.html" title="/en-US/docs/Web/Events/track">track</a></code> event is set&nbsp;to the <code>RTCPeerConnection</code> for each track added to the connection. Making use of newly added media requires implementing a handler for the <code>track</code> event. A common need is to attach&nbsp;the incoming media to an appropriate HTML element. In our example, we add the track's stream to the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video" title="The HTML Video element (<video>) embeds a media player which supports video playback into the document."><code>&lt;video&gt;</code></a> element that displays the incoming video:</p>

<pre class="brush: js">function handleTrackEvent(event) {
  document.getElementById("received_video").srcObject = event.streams[0];
  document.getElementById("hangup-button").disabled = false;
}</pre>

<p>The incoming stream is attached to the <code>"received_video"</code> <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video" title="The HTML Video element (<video>) embeds a media player which supports video playback into the document."><code>&lt;video&gt;</code></a> element, and the "Hang Up" <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button" title="The HTML <button> element represents a clickable button, which can be used in forms or anywhere in a document that needs simple, standard button functionality."><code>&lt;button&gt;</code></a> element is enabled so the user can hang up the call.</p>

<p>Once this code has completed, finally the video being sent by the other peer is displayed in the local browser window!</p>

<h5 id="Handling_the_removal_of_tracks">Handling the removal of tracks</h5>

<p>Your code receives a <code><a href="../VideoTrackList/removetrack_event.html" title="/en-US/docs/Web/Events/removetrack">removetrack</a></code> event when the remote peer removes a track from the connection by calling <a href="../RTCPeerConnection/removeTrack.html" title="The RTCPeerConnection.removeTrack() method tells the local end of the connection to stop sending media from the specified track, without actually removing the corresponding RTCRtpSender from the list of senders as reported by RTCPeerConnection.getSenders()."><code>RTCPeerConnection.removeTrack()</code></a>. Our handler for <code>"removetrack"</code> is:</p>

<pre class="brush: js">function handleRemoveTrackEvent(event) {
  var stream = document.getElementById("received_video").srcObject;
  var trackList = stream.getTracks();
 
  if (trackList.length == 0) {
    closeVideoCall();
  }
}</pre>

<p>This code fetches the incoming video <a href="../MediaStream.html" title="The MediaStream interface represents a stream of media content. A stream consists of several tracks such as&nbsp;video or audio tracks. Each track is specified as an instance of MediaStreamTrack."><code>MediaStream</code></a> from the <code>"received_video"</code> <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video" title="The HTML Video element (<video>) embeds a media player which supports video playback into the document."><code>&lt;video&gt;</code></a> element's <code><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-srcobject">srcobject</a></code> attribute, then calls the stream's <a href="../MediaStream/getTracks.html" title="The&nbsp;getTracks()&nbsp;method of the MediaStream interface returns a sequence that represents&nbsp;all the MediaStreamTrack&nbsp;objects in this stream's&nbsp;track set, regardless of&nbsp;MediaStreamTrack.kind."><code>getTracks()</code></a> method to get an array of the stream's tracks.</p>

<p>If the array's length is zero, meaning there are no tracks left in the stream, we end the call by calling <code>closeVideoCall()</code>. This cleanly restores our app to a state in which it's ready to start or receive another call. See <a href="#Ending_the_call">Ending the call</a> to learn how <code>closeVideoCall()</code> works.</p>

<h4 id="Ending_the_call">Ending the call</h4>

<p>There are many reasons why calls may end. A call might have completed, with one or both sides having hung up. Perhaps a network failure has occurred, or one user might have quit their browser, or had a system&nbsp;crash. In any case, all good things must come to an end.</p>

<h5 id="Hanging_up">Hanging up</h5>

<p>When the user clicks the "Hang Up" button to end the call, the <code>hangUpCall()</code> function is called:</p>

<pre class="brush: js">function hangUpCall() {
  closeVideoCall();
  sendToServer({
    name: myUsername,
    target: targetUsername,
    type: "hang-up"
  });
}</pre>

<p><code>hangUpCall()</code> executes <code>closeVideoCall()</code> to shut down and reset the connection and release resources. It then builds a <code>"hang-up"</code> message and sends it to the other end of the call to tell the other peer to neatly shut itself down.</p>

<h5 id="Ending_the_call_2">Ending the call</h5>

<p>The <code>closeVideoCall()</code> function, shown below, is responsible for stopping the streams, cleaning up, and disposing of the <a href="../RTCPeerConnection.html" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a> object:</p>

<pre class="brush: js">function closeVideoCall() {
  var remoteVideo = document.getElementById("received_video");
  var localVideo = document.getElementById("local_video");

  if (myPeerConnection) {
    myPeerConnection.ontrack = null;
    myPeerConnection.onremovetrack = null;
    myPeerConnection.onremovestream = null;
    myPeerConnection.onicecandidate = null;
    myPeerConnection.oniceconnectionstatechange = null;
    myPeerConnection.onsignalingstatechange = null;
    myPeerConnection.onicegatheringstatechange = null;
    myPeerConnection.onnegotiationneeded = null;

    if (remoteVideo.srcObject) {
      remoteVideo.srcObject.getTracks().forEach(track =&gt; track.stop());
    }

    if (localVideo.srcObject) {
      localVideo.srcObject.getTracks().forEach(track =&gt; track.stop());
    }

    myPeerConnection.close();
    myPeerConnection = null;
  }

  remoteVideo.removeAttribute("src");
  remoteVideo.removeAttribute("srcObject");
  localVideo.removeAttribute("src");
  remoteVideo.removeAttribute("srcObject");

  document.getElementById("hangup-button").disabled = true;
  targetUsername = null;
}
</pre>

<p>After pulling references to the two <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video" title="The HTML Video element (<video>) embeds a media player which supports video playback into the document."><code>&lt;video&gt;</code></a> elements, we check if a WebRTC connection exists; if it does, we proceed to disconnect and close the call:</p>

<ol>
	<li>All of the event handlers are removed. This prevents stray event handlers from being triggered while the connection is in the process of closing, potentially causing errors.</li>
	<li>For both remote and local video streams, we iterate over each track, calling the <a href="../MediaStreamTrack/stop.html" title="In short, the MediaStreamTrack method stop() method stops the track."><code>MediaStreamTrack.stop()</code></a> method to close each one.</li>
	<li>Close the <a href="../RTCPeerConnection.html" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a> by calling <a href="../RTCPeerConnection/close.html" title="The RTCPeerConnection.close() method closes the current peer connection."><code>myPeerConnection.close()</code></a>.</li>
	<li>Set <code>myPeerConnection</code> to <code>null</code>, ensuring our code learns there's no ongoing call; this is useful when the user clicks a name in the user list.</li>
</ol>

<p>Then for both the incoming and outgoing <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video" title="The HTML Video element (<video>) embeds a media player which supports video playback into the document."><code>&lt;video&gt;</code></a> elements, we remove their <code><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-src">src</a></code> and <code><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-srcobject">srcobject</a></code> attributes using their <a href="../Element/removeAttribute.html" title="The Element method removeAttribute() removes the attribute with the specified name from the element."><code>removeAttribute()</code></a> methods. This completes the disassociation of the streams from the video elements.</p>

<p>Finally, we set the <a class="new" href="../HTMLElement/disabled.html" rel="nofollow" title="The documentation about this has not yet been written; please consider contributing!"><code>disabled</code></a> property to <code>true</code> on the "Hang Up" button, making it unclickable while there is no call underway; then we set <code>targetUsername</code> to <code>null</code> since we're no longer talking to anyone. This allows the user to call another user, or to receive an incoming call.</p>

<h4 id="Dealing_with_state_changes">Dealing with state changes</h4>

<p>There are a number of additional events you can set listeners for which notifying your code of a variety of state changes. We use three of them: <code><a href="../RTCPeerConnection/iceconnectionstatechange_event.html" title="/en-US/docs/Web/Events/iceconnectionstatechange">iceconnectionstatechange</a></code>, <code><a href="../RTCPeerConnection/icegatheringstatechange_event.html" title="/en-US/docs/Web/Events/icegatheringstatechange">icegatheringstatechange</a></code>, and <code><a href="../RTCPeerConnection/signalingstatechange_event.html" title="/en-US/docs/Web/Events/signalingstatechange">signalingstatechange</a></code>.</p>

<h5 id="ICE_connection_state">ICE connection state</h5>

<p><code><a href="../RTCPeerConnection/iceconnectionstatechange_event.html" title="/en-US/docs/Web/Events/iceconnectionstatechange">iceconnectionstatechange</a></code> events are sent to the <a href="../RTCPeerConnection.html" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a> by the ICE layer when the connection state changes (such as when the call is terminated from the other end).</p>

<pre class="brush: js">function handleICEConnectionStateChangeEvent(event) {
  switch(myPeerConnection.iceConnectionState) {
    case "closed":
    case "failed":
    case "disconnected":
      closeVideoCall();
      break;
  }
}</pre>

<p>Here, we apply our <code>closeVideoCall()</code> function when the ICE connection state changes to <code>"closed"</code>, <code>"failed"</code>, or <code>"disconnected"</code>. This handles shutting down our end of the connection so that we're ready start or accept a call once again.</p>

<h5 id="ICE_signaling_state">ICE signaling state</h5>

<p>Similarly, we watch for <code><a href="../RTCPeerConnection/signalingstatechange_event.html" title="/en-US/docs/Web/Events/signalingstatechange">signalingstatechange</a></code> events. If the signaling state changes to <code>closed</code>, we likewise close the call out.</p>

<pre class="brush: js">function handleSignalingStateChangeEvent(event) {
  switch(myPeerConnection.signalingState) {
    case "closed":
      closeVideoCall();
      break;
  }
};</pre>

<div class="blockIndicator note">
<p><strong>Note:</strong> The <code>closed</code> signaling state has been deprecated in favor of the <code>closed</code> <a href="../RTCPeerConnection/iceConnectionState.html" title="The read-only property RTCPeerConnection.iceConnectionState returns an enum of type RTCIceConnectionState which state of the ICE agent associated with the RTCPeerConnection."><code>iceConnectionState</code></a>. We are watching for it here to add a bit of backward compatibility.</p>
</div>

<h5 id="ICE_gathering_state">ICE gathering state</h5>

<p><code><a href="../RTCPeerConnection/icegatheringstatechange_event.html" title="/en-US/docs/Web/Events/icegatheringstatechange">icegatheringstatechange</a></code> events are used to let you know when the ICE candidate gathering process state changes. Our example doesn't use this for anything, but it can be useful to watch these events for debugging purposes, as well as to detect when candidate collection has finished.</p>

<pre class="brush: js">function handleICEGatheringStateChangeEvent(event) {
  // Our sample just logs information to console here,
  // but you can do whatever you need.
}
</pre>

<a class="dashAnchor" name="//apple_ref/Section/Next%20steps"></a><h2 id="Next_steps">Next steps</h2>

<p>You can now <a class="external" href="https://webrtc-from-chat.glitch.me/" rel="noopener">try out this example on Glitch</a> to see it in action. Open the Web console on both devices and look at the logged output—although you don't see it in the code as shown above, the code on the server (and on <a class="external" href="https://github.com/mdn/samples-server/tree/master/s/webrtc-from-chat" rel="noopener">GitHub</a>) has a lot of console output so you can see the signaling and connection processes at work.</p>

<p>Another obvious improvement would be to add a "ringing" feature, so that instead of just asking the user for permission to use the camera and microphone, a "User X is calling. Would you like to answer?" prompt appears first.</p>
                  
                
              </article>

              <!-- contributors -->
              <div class="wiki-block contributors">
                <h2 class="offscreen">Document Tags and Contributors</h2>
                
                
  <div class="tag-attach-list contributors-sub">
    <svg class="icon icon-tags" xmlns="http://www.w3.org/2000/svg" width="30" height="28" viewBox="0 0 30 28" aria-hidden="true">
    <path d="M7 7c0-1.109-.891-2-2-2s-2 .891-2 2 .891 2 2 2 2-.891 2-2zm16.672 9c0 .531-.219 1.047-.578 1.406l-7.672 7.688c-.375.359-.891.578-1.422.578s-1.047-.219-1.406-.578L1.422 13.906C.625 13.125 0 11.609 0 10.5V4c0-1.094.906-2 2-2h6.5c1.109 0 2.625.625 3.422 1.422l11.172 11.156c.359.375.578.891.578 1.422zm6 0c0 .531-.219 1.047-.578 1.406l-7.672 7.688a2.08 2.08 0 0 1-1.422.578c-.812 0-1.219-.375-1.75-.922l7.344-7.344c.359-.359.578-.875.578-1.406s-.219-1.047-.578-1.422L14.422 3.422C13.625 2.625 12.11 2 11 2h3.5c1.109 0 2.625.625 3.422 1.422l11.172 11.156c.359.375.578.891.578 1.422z"></path>
</svg>
    <strong>Tags:</strong>&nbsp;
    <ul class="tags tags-small">
      
        <li><a href="../../../tag/API.html" rel="nofollow">API</a></li>
      
        <li><a href="https://developer.mozilla.org/en-US/docs/tag/Audio" rel="nofollow">Audio</a></li>
      
        <li><a href="https://developer.mozilla.org/en-US/docs/tag/Calling" rel="nofollow">Calling</a></li>
      
        <li><a href="https://developer.mozilla.org/en-US/docs/tag/Example" rel="nofollow">Example</a></li>
      
        <li><a href="https://developer.mozilla.org/en-US/docs/tag/Guide" rel="nofollow">Guide</a></li>
      
        <li><a href="https://developer.mozilla.org/en-US/docs/tag/Media" rel="nofollow">Media</a></li>
      
        <li><a href="https://developer.mozilla.org/en-US/docs/tag/Signaling" rel="nofollow">Signaling</a></li>
      
        <li><a href="https://developer.mozilla.org/en-US/docs/tag/Tutorial" rel="nofollow">Tutorial</a></li>
      
        <li><a href="https://developer.mozilla.org/en-US/docs/tag/Video" rel="nofollow">Video</a></li>
      
        <li><a href="https://developer.mozilla.org/en-US/docs/tag/WebRTC" rel="nofollow">WebRTC</a></li>
      
    </ul>
  </div>


                
                  <div class="contributors-sub">
                    <svg class="icon icon-group" xmlns="http://www.w3.org/2000/svg" width="30" height="28" viewBox="0 0 30 28" aria-hidden="true">
    <path d="M9.266 14a5.532 5.532 0 0 0-4.141 2H3.031C1.468 16 0 15.25 0 13.516 0 12.25-.047 8 1.937 8c.328 0 1.953 1.328 4.062 1.328.719 0 1.406-.125 2.078-.359A7.624 7.624 0 0 0 7.999 10c0 1.422.453 2.828 1.266 4zM26 23.953C26 26.484 24.328 28 21.828 28H8.172C5.672 28 4 26.484 4 23.953 4 20.422 4.828 15 9.406 15c.531 0 2.469 2.172 5.594 2.172S20.063 15 20.594 15C25.172 15 26 20.422 26 23.953zM10 4c0 2.203-1.797 4-4 4S2 6.203 2 4s1.797-4 4-4 4 1.797 4 4zm11 6c0 3.313-2.688 6-6 6s-6-2.688-6-6 2.688-6 6-6 6 2.688 6 6zm9 3.516C30 15.25 28.531 16 26.969 16h-2.094a5.532 5.532 0 0 0-4.141-2A7.066 7.066 0 0 0 22 10a7.6 7.6 0 0 0-.078-1.031A6.258 6.258 0 0 0 24 9.328C26.109 9.328 27.734 8 28.062 8c1.984 0 1.937 4.25 1.937 5.516zM28 4c0 2.203-1.797 4-4 4s-4-1.797-4-4 1.797-4 4-4 4 1.797 4 4z"></path>
</svg>
                    <strong>Contributors to this page:</strong>
                    
        <a href="https://developer.mozilla.org/en-US/profiles/GenjoMoz" rel="nofollow">GenjoMoz</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/mdnwebdocs-bot" rel="nofollow">mdnwebdocs-bot</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/nunomsantos" rel="nofollow">nunomsantos</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/mattkrick" rel="nofollow">mattkrick</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/Sheppy" rel="nofollow">Sheppy</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/ashucg" rel="nofollow">ashucg</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/MzMzEckotimez" rel="nofollow">MzMzEckotimez</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/AzazelN28" rel="nofollow">AzazelN28</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/betimer" rel="nofollow">betimer</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/yuriybash" rel="nofollow">yuriybash</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/startgeek" rel="nofollow">startgeek</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/fscholz" rel="nofollow">fscholz</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/drewbard" rel="nofollow">drewbard</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/egeapak" rel="nofollow">egeapak</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/Spidey" rel="nofollow">Spidey</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/hamersun" rel="nofollow">hamersun</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/codedread" rel="nofollow">codedread</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/SphinxKnight" rel="nofollow">SphinxKnight</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/Move" rel="nofollow">Move</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/gustnxodjs" rel="nofollow">gustnxodjs</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/david_ross" rel="nofollow">david_ross</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/Jib" rel="nofollow">Jib</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/denar90" rel="nofollow">denar90</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/chrisdavidmills" rel="nofollow">chrisdavidmills</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/teoli" rel="nofollow">teoli</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/AFBarstow" rel="nofollow">AFBarstow</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/ccampbell1723" rel="nofollow">ccampbell1723</a>, 
    
        <a href="https://developer.mozilla.org/en-US/profiles/wrksprfct" rel="nofollow">wrksprfct</a>
    
                  </div>
                

                
                  <div class="contributors-sub">
                    <svg class="icon icon-clock" xmlns="http://www.w3.org/2000/svg" width="24" height="28" viewBox="0 0 24 28" aria-hidden="true">
    <path d="M14 8.5v7c0 .281-.219.5-.5.5h-5a.494.494 0 0 1-.5-.5v-1c0-.281.219-.5.5-.5H12V8.5c0-.281.219-.5.5-.5h1c.281 0 .5.219.5.5zm6.5 5.5c0-4.688-3.813-8.5-8.5-8.5S3.5 9.313 3.5 14s3.813 8.5 8.5 8.5 8.5-3.813 8.5-8.5zm3.5 0c0 6.625-5.375 12-12 12S0 20.625 0 14 5.375 2 12 2s12 5.375 12 12z"></path>
</svg>
                    <strong>Last updated by:</strong>
                    <a href="https://developer.mozilla.org/en-US/profiles/GenjoMoz" rel="nofollow">GenjoMoz</a>,
                    <time datetime="2019-03-25T07:30:52.534533-07:00">Mar 25, 2019, 7:30:52 AM</time>
                  </div>
                
              </div>
            </div>

            
              <!-- quick links and approvals strip -->
              <div id="wiki-left" class="column-strip wiki-column">

                <!-- crumbs -->
                
  
    
  

                
                  <!-- quick links -->
                  
  <div class="quick-links" id="quick-links">
    <div class="quick-links-head">Related Topics</div>
    
 <ol>
  <li><a href="../WebRTC_API.html"><strong>WebRTC API</strong></a></li>
  <li class="toggle">
    <details open="">
      <summary>WebRTC Guides</summary>
      <ol>
        <li><a href="Protocols.html">WebRTC Architecture</a></li>
        <li><a href="Signaling_and_video_calling.html">WebRTC Basics</a></li>
        <li><a href="Protocols.html">WebRTC Protocols</a></li>
        <li><a href="Connectivity.html">Dealing with connectivity</a></li>
        <li><a href="../WebRTC_API%23WebRTC_concepts_and_usage.html">Overview of WebRTC interfaces</a></li>
        <li><a href="Session_lifetime.html">Lifetime of a WebRTC Session</a></li>
        <li><a href="Using_data_channels.html">Using data channels</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details open="">
      <summary>WebRTC Tutorials</summary>
      <ol>
        <li><a href="adapter.html">Interoperability with adapter.js</a></li>
        <li><a href="Taking_still_photos.html">Taking still photos from the camera</a></li>
        <li><a href="Simple_RTCDataChannel_sample.html">A simple data channel example</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details open="">
      <summary>Interfaces</summary>
      <ol>
        <li><a href="../RTCPeerConnection.html" title="The RTCPeerConnection interface represents a WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed."><code>RTCPeerConnection</code></a></li>
        <li><a href="../RTCSessionDescription.html" title="The RTCSessionDescription interface describes one end of a connection—or potential connection—and how it's configured. Each RTCSessionDescription consists of a description type indicating which part of the offer/answer negotiation process it describes and of the SDP descriptor of the session."><code>RTCSessionDescription</code></a></li>
        <li><a href="../RTCIceCandidate.html" title="The RTCIceCandidate interface—part of the WebRTC API—represents a candidate Internet Connectivity Establishment (ICE) configuration which may be used to establish an RTCPeerConnection."><code>RTCIceCandidate</code></a></li>
        <li><a href="../RTCPeerConnectionIceEvent.html" title="The RTCPeerConnectionIceEvent interface represents events that occurs in relation to ICE candidates with the target, usually an RTCPeerConnection."><code>RTCPeerConnectionIceEvent</code></a></li>
        <li><a href="../MessageEvent.html" title="The MessageEvent interface represents a message received by a target object."><code>MessageEvent</code></a></li>
        <li><a href="../MediaStream.html" title="The MediaStream interface represents a stream of media content. A stream consists of several tracks such as&nbsp;video or audio tracks. Each track is specified as an instance of MediaStreamTrack."><code>MediaStream</code></a></li>
        <li><a href="../RTCStatsReport.html" title="The RTCStatsReport dictionary is contains statistics data about WebRTC connections as returned by the RTCPeerConnection.getStats(), RTCRtpReceiver.getStats(), and RTCRtpSender.getStats() methods."><code>RTCStatsReport</code></a></li>
        <li><a href="../RTCIdentityEvent.html" title="The RTCIdentityEvent interface represents an identity assertion&nbsp;generated by an identity provider (idP). This is usually for an RTCPeerConnection.&nbsp;The only event sent with this type is identityresult.."><code>RTCIdentityEvent</code></a></li>
        <li><a href="../RTCIdentityErrorEvent.html" title="The RTCIdentityErrorEvent interface represents an error associated with the identity provider (idP). This is usually for an&nbsp;RTCPeerConnection.&nbsp;Two events are sent with this type: idpassertionerror and idpvalidationerror."><code>RTCIdentityErrorEvent</code></a></li>
        <li><a href="../MediaStreamEvent.html" title="The MediaStreamEvent interface represents events that occurs in relation to a MediaStream. Two events of this type can be thrown: addstream and removestream."><code>MediaStreamEvent</code></a></li>
        <li><a href="../MediaStreamTrack.html" title="The MediaStreamTrack interface represents&nbsp;a single media track within a stream; typically, these are audio or video tracks, but other track types may exist as well."><code>MediaStreamTrack</code></a></li>
        <li><a href="../MediaDevices.html" title="The MediaDevices interface provides access to connected media input devices like cameras and microphones, as well as screen sharing. In essence, it lets you obtain access to any hardware source of media data."><code>MediaDevices</code></a></li>
      </ol>
    </details>
  </li>
  <li><strong><a href="https://developer.mozilla.org/en-US/docs/MDN">Documentation:</a></strong></li>
  <li class="toggle">
    <details>
      <summary>Useful lists</summary>
      <ol>
        <li><a href="https://developer.mozilla.org/en-US/docs/tag/WebRTC">Pages tagged "WebRTC"</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details>
      <summary>Contribute</summary>
      <ol>
        <li><a href="../../../MDN/Doc_status/API/WebRTC.html">WebRTC doc status</a></li>
        <li><a href="https://developer.mozilla.org/en-US/docs/MDN">The MDN project</a></li>
      </ol>
    </details>
  </li>
 </ol>

  </div>
                

                <!-- approvals -->
                

              </div>
            
          </div>
        </div>
      </div>
    </div> <!-- ends "main-content" -->

    
      <div class="newsletter-box">
        <div class="newsletter">
    <form id="newsletterForm" class="newsletter-form nodisable" name="newsletter-form" action="https://www.mozilla.org/en-US/newsletter/" method="post">
        <div class="newsletter-head">
            <h2 class="newsletter-teaser">Learn the best of web development</h2>
            <p class="newsletter-description">Get the latest and greatest from MDN delivered straight to your inbox.</p>
            
        </div>

        <div class="newsletter-fields">
            <input type="hidden" id="fmt" name="fmt" value="H">
            <input type="hidden" id="newsletterNewslettersInput" name="newsletters" value="app-dev">
            <div id="newsletterErrors" class="newsletter-errors"></div>

            <div id="newsletterEmail" class="form-group newsletter-group-email">
                <label for="newsletterEmailInput" class="form-label offscreen">E-mail</label>
                <input type="email" id="newsletterEmailInput" name="email" class="form-input newsletter-input-email" required="" placeholder="you@example.com" size="30">
            </div>

            <div id="newsletterPrivacy" class="form-group form-group-agree newsletter-group-privacy hidden">
                <input type="checkbox" id="newsletterPrivacyInput" name="privacy" required="">
                <label for="newsletterPrivacyInput">
                I'm okay with Mozilla handling my info as explained in this <a href="https://www.mozilla.org/privacy/">Privacy Policy</a>.
                </label>
            </div>
            <div id="newsletterSubmit" class="newsletter-group-submit">
                <button id="newsletter-submit" type="submit" class="button neutral newsletter-submit">
                    Sign up now<svg class="icon icon-arrow" xmlns="http://www.w3.org/2000/svg" width="23" height="28" viewBox="0 0 23 28" aria-hidden="true">
    <path d="M23 15a2.01 2.01 0 0 1-.578 1.422L12.25 26.594c-.375.359-.891.578-1.422.578s-1.031-.219-1.406-.578L8.25 25.422c-.375-.375-.594-.891-.594-1.422s.219-1.047.594-1.422L12.828 18h-11C.703 18 0 17.062 0 16v-2c0-1.062.703-2 1.828-2h11L8.25 7.406a1.96 1.96 0 0 1 0-2.812l1.172-1.172c.375-.375.875-.594 1.406-.594s1.047.219 1.422.594l10.172 10.172c.375.359.578.875.578 1.406z"></path>
</svg>
                </button>
            </div>
        </div>
    </form>
    <div id="newsletterThanks" class="newsletter-thanks hidden">
        <h2>Thanks! Please check your inbox to confirm your subscription.</h2>
        <p>If you haven’t previously confirmed a subscription to a Mozilla-related newsletter you may have to do so. Please check your inbox or your spam filter for an email from us.
        </p>
    </div>
    <button id="newsletterHide" type="button" class="only-icon newsletter-hide hidden">
        <span>Hide Newsletter Sign-up</span>
        <svg class="icon icon-close" xmlns="http://www.w3.org/2000/svg" width="22" height="28" viewBox="0 0 22 28" aria-hidden="true" role="img"><title></title><path d="M20.281 20.656c0 .391-.156.781-.438 1.062l-2.125 2.125c-.281.281-.672.438-1.062.438s-.781-.156-1.062-.438L11 19.249l-4.594 4.594c-.281.281-.672.438-1.062.438s-.781-.156-1.062-.438l-2.125-2.125c-.281-.281-.438-.672-.438-1.062s.156-.781.438-1.062L6.751 15l-4.594-4.594c-.281-.281-.438-.672-.438-1.062s.156-.781.438-1.062l2.125-2.125c.281-.281.672-.438 1.062-.438s.781.156 1.062.438L11 10.751l4.594-4.594c.281-.281.672-.438 1.062-.438s.781.156 1.062.438l2.125 2.125c.281.281.438.672.438 1.062s-.156.781-.438 1.062L15.249 15l4.594 4.594c.281.281.438.672.438 1.062z"></path></svg>
    </button>
</div>
      </div>
    

  <menu type="context" id="edit-history-menu">
    <menuitem data-action="/en-US/users/signin?next=/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling%24edit" label="Edit page"></menuitem>
    <menuitem data-action="/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling$history" label="View page history"></menuitem>
  </menu>

      </div>
  </main>

  <!-- Footer -->
    <footer id="nav-footer" class="nav-footer"><div class="center"><a href="http://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling">Signaling and video calling</a> by <a href="http://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling$history">Mozilla Contributors</a> is licensed under <a href="http://creativecommons.org/licenses/by-sa/2.5/" class="external external-icon">CC-BY-SA 2.5</a>.</div></footer> 

  <!-- site js -->
  
    
    <!--[if lte IE 8]><script async="" type="text/javascript" src=".selectivizr.8bb9e662e963.js" charset="utf-8"></script><![endif]-->

    
    <script src="../../../../../static/jsi18n/en-US/javascript.414b87adc480.js"></script>
    <script type="text/javascript" src="../../../../../static/build/js/main.07c77248863e.js" charset="utf-8"></script>
    <script>
    if (window.mdn && mdn.analytics) mdn.analytics.trackOutboundLinks();
  </script>
    
  
    <script async="" type="text/javascript" src="../../../../../static/build/js/syntax-prism.js" charset="utf-8"></script><script type="text/javascript" src=".selectivizr.8bb9e662e963.js" charset="utf-8"></script><!--[endif]---->

    
    <script src="../../../../../static/jsi18n/en-US/javascript.414b87adc480.js"></script>
    <script type="text/javascript" src="../../../../../static/build/js/main.07c77248863e.js" charset="utf-8"></script>
    <script>
    if (window.mdn && mdn.analytics) mdn.analytics.trackOutboundLinks();
  </script>
    
  
    <script async="" type="text/javascript" src="../../../../../static/build/js/wiki.c63623e4caba.js" charset="utf-8" id="wikiscript"></script>


  

  

  

  
    <script async="" type="text/javascript" src="../../../../../static/build/js/newsletter.a85c5c2892e5.js" charset="utf-8"></script>
  




<!-- Mirrored from developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 01 May 2019 23:20:33 GMT -->
</body></html>