<!DOCTYPE html>
<html class="no-js hasSidebar hasPageActions hasBreadcrumb conceptual" data-authenticated="false" data-render="docs" dir="ltr" lang="en-us">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <meta content="Import-PSSession (Microsoft.PowerShell.Utility)" property="og:title"/>
  <meta content="https://docs.microsoft.com/_themes/docs.theme/master/en-us/_themes/images/microsoft-header.png" property="og:image"/>
  <meta content="summary" name="twitter:card"/>
  <meta content="@docsmsft" name="twitter:site"/>
  <meta content="Import-PSSession (Microsoft.PowerShell.Utility)" name="twitter:title"/>
  <meta content="The Import-PSSession cmdlet imports commands , such as cmdlets, functions, and aliases, from a PSSession on a local or remote computer into the current session. You can import any command that the Geâ¦" name="twitter:description"/>
  <meta content="https://docs.microsoft.com/_themes/docs.theme/master/en-us/_themes/images/microsoft-header.png" name="twitter:image"/>
  <meta content="Microsoft Logo" name="twitter:image:alt"/>
  <meta content="The Import-PSSession cmdlet imports commands , such as cmdlets, functions, and aliases, from a PSSession on a local or remote computer into the current session. You can import any command that the Geâ¦" name="description"/>
  <meta content="Docs" name="search.ms_sitename"/>
  <meta content="PowerShell_PowerShell-docs_reference" name="search.ms_docsetname"/>
  <meta content="0" name="version"/>
  <meta content="en-us" name="locale"/>
  <meta content="Docs" name="site_name"/>
  <meta content="PowerShell" name="search.ms_product"/>
  <meta content="PowerShell.PowerShell_PowerShell-docs_reference" name="depot_name"/>
  <meta content="https://github.com/PowerShell/PowerShell-Docs/blob/57cd861e6079bc530a60692b1bbf35cfef1d3f35/reference/6/Microsoft.PowerShell.Utility/Import-PSSession.md" name="ref_skeleton_gitcommit"/>
  <meta content="https://github.com/PowerShell/PowerShell-Docs/blob/live/reference/6/Microsoft.PowerShell.Utility/Import-PSSession.md" name="original_ref_skeleton_git_url"/>
  <meta content="2018-03-30 03:35 PM" name="updated_at"/>
  <meta content="bf1a7c0a-f187-4b45-d12a-1a91e2e7ee13" name="document_id"/>
  <meta content="624c188f-e285-b301-5d59-0e9b94e2d3a9" name="document_version_independent_id"/>
  <meta content="powershell" name="page_type"/>
  <meta content="command" name="page_kind"/>
  <meta content="06/09/2017" name="ms.date"/>
  <meta content="2.0.0" name="schema"/>
  <meta content="powershell,cmdlet" name="keywords"/>
  <meta content="http://go.microsoft.com/fwlink/?LinkId=821821" name="online_version"/>
  <meta content="Microsoft.PowerShell.Commands.Utility.dll-Help.xml" name="external_help_file"/>
  <meta content="powershell" name="ms.devlang"/>
  <meta content="INDEX, FOLLOW" name="ROBOTS"/>
  <meta content="sdwheeler" name="author"/>
  <meta content="sewhee" name="ms.author"/>
  <meta content="carmonm" name="manager"/>
  <meta content="/powershell/bread-pscore/toc.yml?view=powershell-6" name="breadcrumb_path"/>
  <meta content="powershell" name="apiPlatform"/>
  <meta content="reference" name="ms.topic"/>
  <meta content="windows, macos, linux" name="ms.tgt_pltfr"/>
  <meta content="powershell-scripting" name="ms.technology"/>
  <meta content="powershell" name="ms.prod"/>
  <meta content="MSDocsHeader-Powershell" name="uhfHeaderId"/>
  <meta content="../psdocs/toc.json?view=powershell-6" name="toc_rel"/>
  <link href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/import-pssession" rel="canonical"/>
  <title>
   Import-PSSession
  </title>
  <link href="../../../../_themes/docs.theme/master/en-us/_themes/css/60aac04b.site.css" rel="stylesheet"/>
  <link href="../../../../_themes/docs.theme/master/en-us/_themes/css/fdb8a38a.conceptual.css" rel="stylesheet"/>
 </head>
 <body dir="ltr" lang="en-us">
  <div class="header-holder">
   <div data-bi-name="header" id="headerAreaHolder">
    <div id="uhf-placeholder">
    </div>
   </div>
   <div class="disclaimer-holder" id="disclaimer-holder">
   </div>
  </div>
  <div class="container mainContainer" data-bi-name="body">
   <div class="content-header" data-bi-name="content-header">
    <div class="content-header-controls">
     <button class="contents-button button-border" data-bi-name="contents-expand" type="button">
      <span class="docon docon-menu">
      </span>
      Contents
     </button>
    </div>
    <div class="content-header-controls">
     <button class="ap-collapse-behavior ap-expanded button-border" data-bi-name="ap-collapse" type="button">
      <span class="docon docon-exit-mode">
      </span>
      Exit focus mode
     </button>
    </div>
   </div>
   <div class="primary-holder">
    <main class="content" data-bi-name="content" dir="ltr" id="main" lang="en-us" role="main">
     <!-- <content> -->
     <h1>
      Import-PSSession
     </h1>
     <div class="metadata">
      <dl class="attributeList">
       <dt>
        Module:
       </dt>
       <dd>
        <a data-linktype="relative-path" href="./Microsoft.PowerShell.Utility.html">
         Microsoft.PowerShell.Utility
        </a>
       </dd>
      </dl>
     </div>
     <div class="summaryHolder">
      <div class="summary">
       Imports commands from another session into the current session.
      </div>
     </div>
     <h2 class="hiddenAnchor" id="syntax">
      Syntax
     </h2>
     <pre class="wrap"><code class="lang-powershell" dir="ltr">Import-PSSession
      [-Prefix &lt;String&gt;]
      [-DisableNameChecking]
      [[-CommandName] &lt;String[]&gt;]
      [-AllowClobber]
      [-ArgumentList &lt;Object[]&gt;]
      [-CommandType &lt;CommandTypes&gt;]
      [-Module &lt;String[]&gt;]
      [-FullyQualifiedModule &lt;ModuleSpecification[]&gt;]
      [[-FormatTypeName] &lt;String[]&gt;]
      [-Certificate &lt;X509Certificate2&gt;]
      [-Session] &lt;PSSession&gt;
      [&lt;CommonParameters&gt;]</code></pre>
     <h2 id="description">
      Description
     </h2>
     <p>
      The
      <strong>
       Import-PSSession
      </strong>
      cmdlet imports commands , such as cmdlets, functions, and aliases, from a PSSession on a local or remote computer into the current session.
You can import any command that the Get-Command cmdlet can find in the PSSession.
     </p>
     <p>
      Use an
      <strong>
       Import-PSSession
      </strong>
      command to import commands from a customized shell, such as a Microsoft Exchange Server shell, or from a session that includes Windows PowerShell modules and snap-ins or other elements that are not in the current session.
     </p>
     <p>
      To import commands, first use the New-PSSession cmdlet to create a PSSession.
Then, use the
      <strong>
       Import-PSSession
      </strong>
      cmdlet to import the commands.
By default,
      <strong>
       Import-PSSession
      </strong>
      imports all commands except for commands that have the same names as commands in the current session.
To import all the commands, use the
      <em>
       AllowClobber
      </em>
      parameter.
     </p>
     <p>
      You can use imported commands just as you would use any command in the session.
When you use an imported command, the imported part of the command runs implicitly in the session from which it was imported.
However, the remote operations are handled entirely by Windows PowerShell.
You need not even be aware of them, except that you must keep the connection to the other session (PSSession) open.
If you close it, the imported commands are no longer available.
     </p>
     <p>
      Because imported commands might take longer to run than local commands,
      <strong>
       Import-PSSession
      </strong>
      adds an
      <em>
       AsJob
      </em>
      parameter to every imported command.
This parameter allows you to run the command as a Windows PowerShell background job.
For more information, see about_Jobs.
     </p>
     <p>
      When you use
      <strong>
       Import-PSSession
      </strong>
      , Windows PowerShell adds the imported commands to a temporary module that exists only in your session and returns an object that represents the module.
To create a persistent module that you can use in future sessions, use the Export-PSSession cmdlet.
     </p>
     <p>
      The
      <strong>
       Import-PSSession
      </strong>
      cmdlet uses the implicit remoting feature of Windows PowerShell.
When you import commands into the current session, they run implicitly in the original session or in a similar session on the originating computer.
     </p>
     <p>
      Beginning in Windows PowerShell 3.0, you can use the Import-Module cmdlet to import modules from a remote session into the current session.
This feature uses implicit remoting.
It is equivalent to using
      <strong>
       Import-PSSession
      </strong>
      to import selected modules from a remote session into the current session.
     </p>
     <h2 id="examples">
      Examples
     </h2>
     <p>
      <strong>
       Example 1: Import all commands from a PSSession
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; $S = New-PSSession -ComputerName Server01

PS C:\&gt; Import-PSSession -Session $S</code></pre>
     <p>
      This command imports all commands from a PSSession on the Server01 computer into the current session, except for commands that have the same names as commands in the current session.
     </p>
     <p>
      Because this command does not use the
      <em>
       CommandName
      </em>
      parameter, it also imports all of the formatting data required for the imported commands.
     </p>
     <p>
      <strong>
       Example 2: Import commands that end with a specific string
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; $S = New-PSSession https://ps.testlabs.com/powershell

PS C:\&gt; Import-PSSession -Session $S -CommandName *-test -FormatTypeName *

PS C:\&gt; New-Test -Name Test1

PS C:\&gt; Get-Test test1 | Run-Test</code></pre>
     <p>
      These commands import the commands with names that end in "-test" from a PSSession into the local session, and then they show how to use an imported cmdlet.
     </p>
     <p>
      The first command uses the New-PSSession cmdlet to create a PSSession.
It saves the PSSession in the $S variable.
     </p>
     <p>
      The second command uses the
      <strong>
       Import-PSSession
      </strong>
      cmdlet to import commands from the PSSession in $S into the current session.
It uses the
      <em>
       CommandName
      </em>
      parameter to specify commands with the Test noun and the
      <em>
       FormatTypeName
      </em>
      parameter to import the formatting data for the Test commands.
     </p>
     <p>
      The third and fourth commands use the imported commands in the current session.
Because imported commands are actually added to the current session, you use the local syntax to run them.
You do not need to use the Invoke-Command cmdlet to run an imported command.
     </p>
     <p>
      <strong>
       Example 3: Import cmdlets from a PSSession
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; $S1 = New-PSSession -ComputerName s1

PS C:\&gt; $S2 = New-PSSession -ComputerName s2

PS C:\&gt; Import-PSSession -Session s1 -Type cmdlet -Name New-Test, Get-Test -FormatTypeName *

PS C:\&gt; Import-PSSession -Session s2 -Type Cmdlet -Name Set-Test -FormatTypeName *

PS C:\&gt; New-Test Test1 | Set-Test -RunType Full</code></pre>
     <p>
      This example shows that you can use imported cmdlets just as you would use local cmdlets.
     </p>
     <p>
      These commands import the New-Test and Get-Test cmdlets from a PSSession on the Server01 computer and the Set-Test cmdlet from a PSSession on the Server02 computer.
     </p>
     <p>
      Even though the cmdlets were imported from different PSSessions, you can pipe an object from one cmdlet to another without error.
     </p>
     <p>
      <strong>
       Example 4: Run an imported command as a background job
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; $S = New-PSSession -ComputerName Server01

PS C:\&gt; Import-PSSession -Session $S -CommandName *-test* -FormatTypeName *

PS C:\&gt; $batch = New-Test -Name Batch -AsJob

PS C:\&gt; Receive-Job $batch</code></pre>
     <p>
      This example shows how to run an imported command as a background job.
     </p>
     <p>
      Because imported commands might take longer to run than local commands,
      <strong>
       Import-PSSession
      </strong>
      adds an
      <em>
       AsJob
      </em>
      parameter to every imported command.
The
      <em>
       AsJob
      </em>
      parameter lets you run the command as a background job.
     </p>
     <p>
      The first command creates a PSSession on the Server01 computer and saves the PSSession object in the $S variable.
     </p>
     <p>
      The second command uses
      <strong>
       Import-PSSession
      </strong>
      to import the Test cmdlets from the PSSession in $S into the current session.
     </p>
     <p>
      The third command uses the
      <em>
       AsJob
      </em>
      parameter of the imported New-Test cmdlet to run a New-Test command as a background job.
The command saves the job object that New-Test returns in the $batch variable.
     </p>
     <p>
      The fourth command uses the Receive-Job cmdlet to get the results of the job in the $batch variable.
     </p>
     <p>
      <strong>
       Example 5: Import cmdlets and functions from a Windows PowerShell module
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; $S = New-PSSession -ComputerName Server01

PS C:\&gt; Invoke-Command -Session $S {Import-Module TestManagement}

PS C:\&gt; Import-PSSession -Session $S -Module TestManagement</code></pre>
     <p>
      This example shows how to import the cmdlets and functions from a Windows PowerShell module on a remote computer into the current session.
     </p>
     <p>
      The first command creates a PSSession on the Server01 computer and saves it in the $S variable.
     </p>
     <p>
      The second command uses the
      <strong>
       Invoke-Command
      </strong>
      cmdlet to run an Import-Module command in the PSSession in $S.
     </p>
     <p>
      Typically, the module would be added to all sessions by an
      <strong>
       Import-Module
      </strong>
      command in a Windows PowerShell profile, but profiles are not run in PSSessions.
     </p>
     <p>
      The third command uses the
      <em>
       Module
      </em>
      parameter of
      <strong>
       Import-PSSession
      </strong>
      to import the cmdlets and functions in the module into the current session.
     </p>
     <p>
      <strong>
       Example 6: Create a module in a temporary file
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; Import-PSSession $S -CommandName Get-Date, SearchHelp -FormatTypeName * -AllowClobber



Name              : tmp_79468106-4e1d-4d90-af97-1154f9317239_tcw1zunz.ttf

Path              : C:\Users\User01\AppData\Local\Temp\tmp_79468106-4e1d-4d90-af97-1154f9317239_tcw1zunz.ttf\tmp_79468106-4e1d-4d90-af97-1154f9317239_

tcw1zunz.ttf.psm1

Description       : Implicit remoting for http://server01.corp.fabrikam.com/wsman

Guid              : 79468106-4e1d-4d90-af97-1154f9317239

Version           : 1.0

ModuleBase        : C:\Users\User01\AppData\Local\Temp\tmp_79468106-4e1d-4d90-af97-1154f9317239_tcw1zunz.ttf

ModuleType        : Script

PrivateData       : {ImplicitRemoting}

AccessMode        : ReadWrite

ExportedAliases   : {}

ExportedCmdlets   : {}

ExportedFunctions : {[Get-Date, Get-Date], [SearchHelp, SearchHelp]}

ExportedVariables : {}

NestedModules     : {}</code></pre>
     <p>
      This example shows that
      <strong>
       Import-PSSession
      </strong>
      creates a module in a temporary file on disk.
It also shows that all commands are converted into functions before they are imported into the current session.
     </p>
     <p>
      The command uses the
      <strong>
       Import-PSSession
      </strong>
      cmdlet to import a Get-Date cmdlet and a SearchHelp function into the current session.
     </p>
     <p>
      The
      <strong>
       Import-PSSession
      </strong>
      cmdlet returns a
      <strong>
       PSModuleInfo
      </strong>
      object that represents the temporary module.
The value of the
      <strong>
       Path
      </strong>
      property shows that
      <strong>
       Import-PSSession
      </strong>
      created a script module (.psm1) file in a temporary location.
The
      <strong>
       ExportedFunctions
      </strong>
      property shows that the
      <strong>
       Get-Date
      </strong>
      cmdlet and the SearchHelp function were both imported as functions.
     </p>
     <p>
      <strong>
       Example 7: Run a command that is hidden by an imported command
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; Import-PSSession $S -CommandName Get-Date -FormatTypeName * -AllowClobber



PS C:\&gt; Get-Command Get-Date -All



CommandType   Name       Definition

-----------   ----       ----------

Function      Get-Date   ...

Cmdlet        Get-Date   Get-Date [[-Date] &lt;DateTime&gt;] [-Year &lt;Int32&gt;] [-Month &lt;Int32&gt;]



PS C:\&gt; Get-Date

09074



PS C:\&gt; (Get-Command -Type Cmdlet -Name Get-Date).PSSnapin.Name

Microsoft.PowerShell.Utility



PS C:\&gt; Microsoft.PowerShell.Utility\Get-Date

Sunday, March 15, 2009 2:08:26 PM</code></pre>
     <p>
      This example shows how to run a command that is hidden by an imported command.
     </p>
     <p>
      The first command imports a Get-Date cmdlet from the PSSession in the $S variable.
Because the current session includes a
      <strong>
       Get-Date
      </strong>
      cmdlet, the
      <em>
       AllowClobber
      </em>
      parameter is required in the command.
     </p>
     <p>
      The second command uses the
      <strong>
       All
      </strong>
      parameter of the Get-Command cmdlet to get all
      <strong>
       Get-Date
      </strong>
      commands in the current session.
The output shows that the session includes the original
      <strong>
       Get-Date
      </strong>
      cmdlet and a
      <strong>
       Get-Date
      </strong>
      function.
The
      <strong>
       Get-Date
      </strong>
      function runs the imported
      <strong>
       Get-Date
      </strong>
      cmdlet in the PSSession in $S.
     </p>
     <p>
      The third command runs a
      <strong>
       Get-Date
      </strong>
      command.
Because functions take precedence over cmdlets, Windows PowerShell runs the imported
      <strong>
       Get-Date
      </strong>
      function, which returns a Julian date.
     </p>
     <p>
      The fourth and fifth commands show how to use a qualified name to run a command that is hidden by an imported command.
     </p>
     <p>
      The fourth command gets the name of the Windows PowerShell snap-in that added the original
      <strong>
       Get-Date
      </strong>
      cmdlet to the current session.
     </p>
     <p>
      The fifth command uses the snap-in-qualified name of the
      <strong>
       Get-Date
      </strong>
      cmdlet to run a
      <strong>
       Get-Date
      </strong>
      command.
     </p>
     <p>
      For more information about command precedence and hidden commands, see about_Command_Precedence.
     </p>
     <p>
      <strong>
       Example 8: Import commands that have a specific string in their names
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; Import-PSSession -Session $S -CommandName *Item* -AllowClobber</code></pre>
     <p>
      This command imports commands whose names include Item from the PSSession in $S.
Because the command includes the
      <em>
       CommandName
      </em>
      parameter but not the
      <em>
       FormatTypeData
      </em>
      parameter, only the command is imported.
     </p>
     <p>
      Use this command when you are using
      <strong>
       Import-PSSession
      </strong>
      to run a command on a remote computer and you already have the formatting data for the command in the current session.
     </p>
     <p>
      <strong>
       Example 9: Use the Module parameter to discover which commands were imported into the session
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; $M = Import-PSSession -Session $S -CommandName *bits* -FormatTypeName *bits*

PS C:\&gt; Get-Command -Module $M

CommandType     Name

-----------     ----

Function        Add-BitsFile

Function        Complete-BitsTransfer

Function        Get-BitsTransfer

Function        Remove-BitsTransfer

Function        Resume-BitsTransfer

Function        Set-BitsTransfer

Function        Start-BitsTransfer

Function        Suspend-BitsTransfer</code></pre>
     <p>
      This command shows how to use the
      <em>
       Module
      </em>
      parameter of
      <strong>
       Get-Command
      </strong>
      to find out which commands were imported into the session by an
      <strong>
       Import-PSSession
      </strong>
      command.
     </p>
     <p>
      The first command uses the
      <strong>
       Import-PSSession
      </strong>
      cmdlet to import commands whose names include "bits" from the PSSession in the $S variable.
The
      <strong>
       Import-PSSession
      </strong>
      command returns a temporary module, and the command saves the module in the $m variable.
     </p>
     <p>
      The second command uses the Get-Command cmdlet to get the commands that are exported by the module in the $M variable.
     </p>
     <p>
      The
      <em>
       Module
      </em>
      parameter takes a string value, which is designed for the module name.
However, when you submit a module object, Windows PowerShell uses the
      <strong>
       ToString
      </strong>
      method on the module object, which returns the module name.
     </p>
     <p>
      The
      <strong>
       Get-Command
      </strong>
      command is the equivalent of
      <code>
       Get-Command $M.Name
      </code>
      ".
     </p>
     <h2 id="required-parameters">
      Required Parameters
     </h2>
     <div class="parameterName stack">
      -Session
     </div>
     <div class="parameterInfo">
      <p>
       Specifies the
       <strong>
        PSSession
       </strong>
       from which the cmdlets are imported.
Enter a variable that contains a session object or a command that gets a session object, such as a New-PSSession or Get-PSSession command.
You can specify only one session.
This parameter is required.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          PSSession
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         1
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <h2 id="optional-parameters">
      Optional Parameters
     </h2>
     <div class="parameterName stack">
      -AllowClobber
     </div>
     <div class="parameterInfo">
      <p>
       Indicates that this cmdlet imports the specified commands, even if they have the same names as commands in the current session.
      </p>
      <p>
       If you import a command with the same name as a command in the current session, the imported command hides or replaces the original commands.
For more information, see about_Command_Precedence.
      </p>
      <p>
       By default,
       <strong>
        Import-PSSession
       </strong>
       does not import commands that have the same name as commands in the current session.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          SwitchParameter
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -ArgumentList
     </div>
     <div class="parameterInfo">
      <p>
       Specifies an array of commands that results from using the specified arguments (parameter values).
      </p>
      <p>
       For instance, to import the variant of the Get-Item command in the certificate (Cert:) drive in the PSSession in $S, type
       <code>
        Import-PSSession -Session $S -Command Get-Item -ArgumentList cert:
       </code>
       .
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          Object[]
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Aliases:
        </td>
        <td>
         Args
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -Certificate
     </div>
     <div class="parameterInfo">
      <p>
       Specifies the client certificate that is used to sign the format files (
       <em>
        .Format.ps1xml) or script module files (.psm1) in the temporary module that **Import-PSSession
       </em>
       * creates.
      </p>
      <p>
       Enter a variable that contains a certificate or a command or expression that gets the certificate.
      </p>
      <p>
       To find a certificate, use the Get-PfxCertificate cmdlet or use the Get-ChildItem cmdlet in the Certificate (Cert:) drive.
If the certificate is not valid or does not have sufficient authority, the command fails.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          X509Certificate2
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -CommandName
     </div>
     <div class="parameterInfo">
      <p>
       Specifies commands with the specified names or name patterns.
Wildcards are permitted.
Use
       <em>
        CommandName
       </em>
       or its alias,
       <em>
        Name
       </em>
       .
      </p>
      <p>
       By default,
       <strong>
        Import-PSSession
       </strong>
       imports all commands from the session, except for commands that have the same names as commands in the current session.
This prevents imported commands from hiding or replacing commands in the session.
To import all commands, even those that hide or replace other commands, use the
       <em>
        AllowClobber
       </em>
       parameter.
      </p>
      <p>
       If you use the
       <em>
        CommandName
       </em>
       parameter, the formatting files for the commands are not imported unless you use the
       <em>
        FormatTypeName
       </em>
       parameter.
Similarly, if you use the
       <em>
        FormatTypeName
       </em>
       parameter, no commands are imported unless you use the
       <em>
        CommandName
       </em>
       parameter.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          String[]
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Aliases:
        </td>
        <td>
         Name
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         3
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -CommandType
     </div>
     <div class="parameterInfo">
      <p>
       Specifies the type of command objects.
The default value is Cmdlet.
Use
       <em>
        CommandType
       </em>
       or its alias,
       <em>
        Type
       </em>
       .
The acceptable values for this parameter are:
      </p>
      <ul>
       <li>
        Alias.
The Windows PowerShell aliases in the remote session.
       </li>
       <li>
        All.
The cmdlets and functions in the remote session.
       </li>
       <li>
        Application.
All the files other than Windows-PowerShell files in the paths that are listed in the Path environment variable ($env:path) in the remote session, including .txt, .exe, and .dll files.
       </li>
       <li>
        Cmdlet.
The cmdlets in the remote session.
"Cmdlet" is the default.
       </li>
       <li>
        ExternalScript.
The .ps1 files in the paths listed in the Path environment variable ($env:path) in the remote session.
       </li>
       <li>
        Filter and Function.
The Windows PowerShell functions in the remote session.
       </li>
       <li>
        Script.
The script blocks in the remote session.
       </li>
      </ul>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          CommandTypes
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Aliases:
        </td>
        <td>
         Type
        </td>
       </tr>
       <tr>
        <td>
         Parameter Sets:
        </td>
        <td>
         Alias, Function, Filter, Cmdlet, ExternalScript, Application, Script, Workflow, Configuration, All
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -DisableNameChecking
     </div>
     <div class="parameterInfo">
      <p>
       Indicates that this cmdlet suppresses the message that warns you when you import a cmdlet or function whose name includes an unapproved verb or a prohibited character.
      </p>
      <p>
       By default, when a module that you import exports cmdlets or functions that have unapproved verbs in their names, the Windows PowerShell displays the following warning message:
      </p>
      <p>
       "WARNING: Some imported command names include unapproved verbs which might make them less discoverable.
Use the Verbose parameter for more detail or type Get-Verb to see the list of approved verbs."
      </p>
      <p>
       This message is only a warning.
The complete module is still imported, including the non-conforming commands.
Although the message is displayed to module users, the naming problem should be fixed by the module author.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          SwitchParameter
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -FormatTypeName
     </div>
     <div class="parameterInfo">
      <p>
       Specifies formatting instructions for the specified Microsoft .NET Framework types.
Enter the type names.
Wildcards are permitted.
      </p>
      <p>
       The value of this parameter must be the name of a type that is returned by a Get-FormatData command in the session from which the commands are being imported.
To get all of the formatting data in the remote session, type *.
      </p>
      <p>
       If the command does not include either the
       <em>
        CommandName
       </em>
       or
       <em>
        FormatTypeName
       </em>
       parameter,
       <strong>
        Import-PSSession
       </strong>
       imports formatting instructions for all .NET Framework types returned by a
       <strong>
        Get-FormatData
       </strong>
       command in the remote session.
      </p>
      <p>
       If you use the
       <em>
        FormatTypeName
       </em>
       parameter, no commands are imported unless you use the
       <em>
        CommandName
       </em>
       parameter.
      </p>
      <p>
       Similarly, if you use the
       <em>
        CommandName
       </em>
       parameter, the formatting files for the commands are not imported unless you use the
       <em>
        FormatTypeName
       </em>
       parameter.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          String[]
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         4
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -FullyQualifiedModule
     </div>
     <div class="parameterInfo">
      <p>
       Specifies modules with names that are specified in the form of
       <strong>
        ModuleSpecification
       </strong>
       objects (described in the Remarks section of
       <a data-linktype="external" href="https://msdn.microsoft.com/library/jj136290">
        ModuleSpecification Constructor (Hashtable)
       </a>
       in the MSDN library).
For example, the
       <em>
        FullyQualifiedModule
       </em>
       parameter accepts a module name that is specified in the format @{ModuleName = "modulename"; ModuleVersion = "version_number"} or @{ModuleName = "modulename"; ModuleVersion = "version_number"; Guid = "GUID"}.
       <strong>
        ModuleName
       </strong>
       and
       <strong>
        ModuleVersion
       </strong>
       are required, but
       <strong>
        Guid
       </strong>
       is optional.
      </p>
      <p>
       You cannot specify the
       <em>
        FullyQualifiedModule
       </em>
       parameter in the same command as a
       <em>
        Module
       </em>
       parameter; the two parameters are mutually exclusive.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          ModuleSpecification[]
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -Module
     </div>
     <div class="parameterInfo">
      <p>
       Specifies and array of commands in the Windows PowerShell snap-ins and modules.
Enter the snap-in and module names.
Wildcards are not permitted.
      </p>
      <p>
       <strong>
        Import-PSSession
       </strong>
       cannot import providers from a snap-in.
      </p>
      <p>
       For more information, see about_PSSnapins and about_Modules.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          String[]
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Aliases:
        </td>
        <td>
         PSSnapin
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -Prefix
     </div>
     <div class="parameterInfo">
      <p>
       Specifies a prefix to the nouns in the names of imported commands.
      </p>
      <p>
       Use this parameter to avoid name conflicts that might occur when different commands in the session have the same name.
      </p>
      <p>
       For instance, if you specify the prefix Remote and then import a Get-Date cmdlet, the cmdlet is known in the session as Get-RemoteDate, and it is not confused with the original
       <strong>
        Get-Date
       </strong>
       cmdlet.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          String
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <h2 id="inputs">
      Inputs
     </h2>
     <p>
      <strong>
       None
      </strong>
     </p>
     <p>
      You cannot pipe objects to this cmdlet.
     </p>
     <h2 id="outputs">
      Outputs
     </h2>
     <p>
      <strong>
       System.Management.Automation.PSModuleInfo
      </strong>
     </p>
     <p>
      <strong>
       Import-PSSession
      </strong>
      returns the same module object that New-Module and Get-Module cmdlets return.
However, the imported module is temporary and exists only in the current session.
To create a permanent module on disk, use the Export-PSSession cmdlet.
     </p>
     <h2 id="notes">
      Notes
     </h2>
     <ul>
      <li>
       <strong>
        Import-PSSession
       </strong>
       relies on the Windows PowerShell remoting infrastructure. To use this cmdlet, the computer must be configured for WS-Management remoting. For more information, see about_Remote and about_Remote_Requirements.
      </li>
      <li>
       <strong>
        Import-PSSession
       </strong>
       does not import variables or Windows PowerShell providers.
      </li>
      <li>
       When you import commands that have the same names as commands in the current session, the imported commands can hide aliases, functions, and cmdlets in the session and they can replace functions and variables in the session. To prevent name conflicts, use the
       <em>
        Prefix
       </em>
       parameter. For more information, see about_Command_Precedence.
      </li>
      <li>
       <strong>
        Import-PSSession
       </strong>
       converts all commands into functions before it imports them. As a result, imported commands behave a bit differently than they would if they retained their original command type. For example, if you import a cmdlet from a PSSession and then import a cmdlet with the same name from a module or snap-in, the cmdlet that is imported from the PSSession always runs by default because functions take precedence over cmdlets. Conversely, if you import an alias into a session that has an alias with the same name, the original alias is always used, because aliases take precedence over functions. For more information, see about_Command_Precedence.
      </li>
      <li>
       <strong>
        Import-PSSession
       </strong>
       uses the Write-Progress cmdlet to display the progress of the command. You might see the progress bar while the command is running.
      </li>
      <li>
       To find the commands to import,
       <strong>
        Import-PSSession
       </strong>
       uses the Invoke-Command cmdlet to run a Get-Command command in the PSSession. To get formatting data for the commands, it uses the Get-FormatData cmdlet. You might see error messages from these cmdlets when you run an
       <strong>
        Import-PSSession
       </strong>
       command. Also,
       <strong>
        Import-PSSession
       </strong>
       cannot import commands from a PSSession that does not include the Get-Command, Get-FormatData, Select-Object, and Get-Help cmdlets.
      </li>
      <li>
       Imported commands have the same limitations as other remote commands, including the inability to start a program with a user interface, such as Notepad.
      </li>
      <li>
       Because Windows PowerShell profiles are not run in PSSessions, the commands that a profile adds to a session are not available to
       <strong>
        Import-PSSession
       </strong>
       . To import commands from a profile, use an Invoke-Command command to run the profile in the PSSession manually before importing commands.
      </li>
      <li>
       The temporary module that
       <strong>
        Import-PSSession
       </strong>
       creates might include a formatting file, even if the command does not import formatting data. If the command does not import formatting data, any formatting files that are created will not contain formatting data.
      </li>
      <li>
       To use
       <strong>
        Import-PSSession
       </strong>
       , the execution policy in the current session cannot be Restricted or AllSigned, because the temporary module that
       <strong>
        Import-PSSession
       </strong>
       creates contains unsigned script files that are prohibited by these policies. To use
       <strong>
        Import-PSSession
       </strong>
       without changing the execution policy for the local computer, use the
       <em>
        Scope
       </em>
       parameter of Set-ExecutionPolicy to set a less restrictive execution policy for a single process.
      </li>
      <li>
       In Windows PowerShell 2.0, help topics for commands that are imported from another session do not include the prefix that you assign by using the
       <em>
        Prefix
       </em>
       parameter. To get help for an imported command in Windows PowerShell 2.0, use the original (non-prefixed) command name.
      </li>
     </ul>
     <h2 id="related-links">
      Related Links
     </h2>
     <ul>
      <li>
       <a data-linktype="relative-path" href="export-pssession.html">
        Export-PSSession
       </a>
      </li>
     </ul>
     <!-- </content> -->
    </main>
    <div class="note alert feedback-system-change-alert">
     <p>
      Note
     </p>
     <p>
      The feedback system for this content will be changing soon. Old comments will not be carried over. If content within a comment thread is important to you, please save a copy. For more information on the upcoming change,
      <a href="https://docs.microsoft.com/teamblog/a-new-feedback-system-is-coming-to-docs">
       we invite you to read our blog post
      </a>
      .
     </p>
    </div>
    <div data-bi-name="comments" id="comments-container" role="form">
    </div>
   </div>
  </div>
  <div class="openfeedback-container" id="openFeedbackContainer">
  </div>
  <div class="action-panel">
  </div>
 </body>
</html>