<!DOCTYPE html>
<html class="no-js hasSidebar hasPageActions hasBreadcrumb conceptual" data-authenticated="false" data-render="docs" dir="ltr" lang="en-us">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <meta content="Export-PSSession (Microsoft.PowerShell.Utility)" property="og:title"/>
  <meta content="https://docs.microsoft.com/_themes/docs.theme/master/en-us/_themes/images/microsoft-header.png" property="og:image"/>
  <meta content="summary" name="twitter:card"/>
  <meta content="@docsmsft" name="twitter:site"/>
  <meta content="Export-PSSession (Microsoft.PowerShell.Utility)" name="twitter:title"/>
  <meta content="The Export-PSSession cmdlet gets cmdlets, functions, aliases, and other command types from another PSSession on a local or remote computer and saves them in a Windows PowerShell module. To add the coâ¦" name="twitter:description"/>
  <meta content="https://docs.microsoft.com/_themes/docs.theme/master/en-us/_themes/images/microsoft-header.png" name="twitter:image"/>
  <meta content="Microsoft Logo" name="twitter:image:alt"/>
  <meta content="The Export-PSSession cmdlet gets cmdlets, functions, aliases, and other command types from another PSSession on a local or remote computer and saves them in a Windows PowerShell module. To add the coâ¦" name="description"/>
  <meta content="Docs" name="search.ms_sitename"/>
  <meta content="PowerShell_PowerShell-docs_reference" name="search.ms_docsetname"/>
  <meta content="0" name="version"/>
  <meta content="en-us" name="locale"/>
  <meta content="Docs" name="site_name"/>
  <meta content="PowerShell" name="search.ms_product"/>
  <meta content="PowerShell.PowerShell_PowerShell-docs_reference" name="depot_name"/>
  <meta content="https://github.com/PowerShell/PowerShell-Docs/blob/617301cc0a194afdca440ba75f5cec2a540ce619/reference/6/Microsoft.PowerShell.Utility/Export-PSSession.md" name="ref_skeleton_gitcommit"/>
  <meta content="https://github.com/PowerShell/PowerShell-Docs/blob/live/reference/6/Microsoft.PowerShell.Utility/Export-PSSession.md" name="original_ref_skeleton_git_url"/>
  <meta content="2018-03-30 03:35 PM" name="updated_at"/>
  <meta content="fa593388-cf3c-2565-7ffe-1e36f15387ce" name="document_id"/>
  <meta content="91dddfc7-3e8e-16dc-98e8-b22868f7ba92" name="document_version_independent_id"/>
  <meta content="powershell" name="page_type"/>
  <meta content="command" name="page_kind"/>
  <meta content="06/09/2017" name="ms.date"/>
  <meta content="2.0.0" name="schema"/>
  <meta content="powershell,cmdlet" name="keywords"/>
  <meta content="http://go.microsoft.com/fwlink/?LinkId=821771" name="online_version"/>
  <meta content="Microsoft.PowerShell.Commands.Utility.dll-Help.xml" name="external_help_file"/>
  <meta content="powershell" name="ms.devlang"/>
  <meta content="INDEX, FOLLOW" name="ROBOTS"/>
  <meta content="sdwheeler" name="author"/>
  <meta content="sewhee" name="ms.author"/>
  <meta content="carmonm" name="manager"/>
  <meta content="/powershell/bread-pscore/toc.yml?view=powershell-6" name="breadcrumb_path"/>
  <meta content="powershell" name="apiPlatform"/>
  <meta content="reference" name="ms.topic"/>
  <meta content="windows, macos, linux" name="ms.tgt_pltfr"/>
  <meta content="powershell-scripting" name="ms.technology"/>
  <meta content="powershell" name="ms.prod"/>
  <meta content="MSDocsHeader-Powershell" name="uhfHeaderId"/>
  <meta content="../psdocs/toc.json?view=powershell-6" name="toc_rel"/>
  <link href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/export-pssession" rel="canonical"/>
  <title>
   Export-PSSession
  </title>
  <link href="../../../../_themes/docs.theme/master/en-us/_themes/css/60aac04b.site.css" rel="stylesheet"/>
  <link href="../../../../_themes/docs.theme/master/en-us/_themes/css/fdb8a38a.conceptual.css" rel="stylesheet"/>
 </head>
 <body dir="ltr" lang="en-us">
  <div class="header-holder">
   <div data-bi-name="header" id="headerAreaHolder">
    <div id="uhf-placeholder">
    </div>
   </div>
   <div class="disclaimer-holder" id="disclaimer-holder">
   </div>
  </div>
  <div class="container mainContainer" data-bi-name="body">
   <div class="content-header" data-bi-name="content-header">
    <div class="content-header-controls">
     <button class="contents-button button-border" data-bi-name="contents-expand" type="button">
      <span class="docon docon-menu">
      </span>
      Contents
     </button>
    </div>
    <div class="content-header-controls">
     <button class="ap-collapse-behavior ap-expanded button-border" data-bi-name="ap-collapse" type="button">
      <span class="docon docon-exit-mode">
      </span>
      Exit focus mode
     </button>
    </div>
   </div>
   <div class="primary-holder">
    <main class="content" data-bi-name="content" dir="ltr" id="main" lang="en-us" role="main">
     <!-- <content> -->
     <h1>
      Export-PSSession
     </h1>
     <div class="metadata">
      <dl class="attributeList">
       <dt>
        Module:
       </dt>
       <dd>
        <a data-linktype="relative-path" href="./Microsoft.PowerShell.Utility.html">
         Microsoft.PowerShell.Utility
        </a>
       </dd>
      </dl>
     </div>
     <div class="summaryHolder">
      <div class="summary">
       Imports commands from another session and saves them in a Windows PowerShell module.
      </div>
     </div>
     <h2 class="hiddenAnchor" id="syntax">
      Syntax
     </h2>
     <pre class="wrap"><code class="lang-powershell" dir="ltr">Export-PSSession
      [-OutputModule] &lt;String&gt;
      [-Force]
      [-Encoding &lt;String&gt;]
      [[-CommandName] &lt;String[]&gt;]
      [-AllowClobber]
      [-ArgumentList &lt;Object[]&gt;]
      [-CommandType &lt;CommandTypes&gt;]
      [-Module &lt;String[]&gt;]
      [-FullyQualifiedModule &lt;ModuleSpecification[]&gt;]
      [[-FormatTypeName] &lt;String[]&gt;]
      [-Certificate &lt;X509Certificate2&gt;]
      [-Session] &lt;PSSession&gt;
      [&lt;CommonParameters&gt;]</code></pre>
     <h2 id="description">
      Description
     </h2>
     <p>
      The
      <strong>
       Export-PSSession
      </strong>
      cmdlet gets cmdlets, functions, aliases, and other command types from another PSSession on a local or remote computer and saves them in a Windows PowerShell module.
To add the commands from the module to the current session, use the Import-Module cmdlet.
     </p>
     <p>
      Unlike Import-PSSession, which imports commands from another PSSession into the current session,
      <strong>
       Export-PSSession
      </strong>
      saves the commands in a module.
The commands are not imported into the current session.
     </p>
     <p>
      To export commands, first use the New-PSSession cmdlet to create a PSSession that has the commands that you want to export.
Then use the
      <strong>
       Export-PSSession
      </strong>
      cmdlet to export the commands.
By default,
      <strong>
       Export-PSSession
      </strong>
      exports all commands, except for commands that exist in the current session, but you can use the
      <em>
       CommandName
      </em>
      parameter to specify the commands to export.
     </p>
     <p>
      The
      <strong>
       Export-PSSession
      </strong>
      cmdlet uses the implicit remoting feature of Windows PowerShell.
When you import commands into the current session, they run implicitly in the original session or in a similar session on the originating computer.
     </p>
     <h2 id="examples">
      Examples
     </h2>
     <p>
      <strong>
       Example 1: Export commands from a PSSession
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; $S = New-PSSession -ComputerName "Server01"

PS C:\&gt; Export-PSSession -Session $S -OutputModule "Server01"</code></pre>
     <p>
      The commands in this example export all commands from a PSSession on the Server01 computer to the Server01 module on the local computer except for commands that have the same names as commands in the current session.
It also exports the formatting data for the commands.
     </p>
     <p>
      The first command creates a PSSession on the Server01 computer.
The second command exports the commands and formatting data from the session into the Server01 module.
     </p>
     <p>
      <strong>
       Example 2: Export Get and Set commands
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; $S = New-PSSession -ConnectionUri http://exchange.microsoft.com/mailbox -Credential exchangeadmin01@hotmail.com -Authentication Negotiate

PS C:\&gt; Export-PSSession -Session $R -Module exch* -CommandName get-*, set-* -FormatTypeName * -OutputModule $pshome\Modules\Exchange -Encoding ASCII</code></pre>
     <p>
      These commands export the Get and Set commands from a Microsoft Exchange Server snap-in on a remote computer to an Exchange module in the $pshome\Modules directory on the local computer.
     </p>
     <p>
      Placing the module in the $pshome\Module directory makes it accessible to all users of the computer.
     </p>
     <p>
      <strong>
       Example 3: Export commands from a remote computer
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; $S = New-PSSession -ComputerName Server01 -Credential Server01\User01

PS C:\&gt; Export-PSSession -Session $S -OutputModule TestCmdlets -Type cmdlet -CommandName *test* -FormatTypeName *

PS C:\&gt; Remove-PSSession $S

PS C:\&gt; Import-Module TestCmdlets

PS C:\&gt; Get-Help Test*

PS C:\&gt; Test-Files</code></pre>
     <p>
      These commands export cmdlets from a PSSession on a remote computer and save them in a module on the local computer.
Then, the commands add the cmdlets from the module to the current session so that they can be used.
     </p>
     <p>
      The first command creates a PSSession on the Server01 computer and saves it in the $S variable.
     </p>
     <p>
      The second command exports the cmdlets whose names begin with Test from the PSSession in $S to the TestCmdlets module on the local computer.
     </p>
     <p>
      The third command uses the Remove-PSSession cmdlet to delete the PSSession in $S from the current session.
This command shows that the PSSession need not be active to use the commands that were imported from it.
     </p>
     <p>
      The fourth command, which can be run in any session at any time, uses the Import-Module cmdlet to add the cmdlets in the TestCmdlets module to the current session.
     </p>
     <p>
      The fifth command uses the Get-Help cmdlet to get help for cmdlets whose names begin with Test.
After the commands in a module are added to the current session, you can use the Get-Help and Get-Command cmdlets to learn about the imported commands, just as you would use them for any command in the session.
     </p>
     <p>
      The sixth command uses the
      <strong>
       Test-Files
      </strong>
      cmdlet, which was exported from the Server01 computer and added to the session.
     </p>
     <p>
      Although it is not evident, the
      <strong>
       Test-Files
      </strong>
      command actually runs in a remote session on the computer from which the command was imported.
Windows PowerShell creates a session from information that is stored in the module.
     </p>
     <p>
      <strong>
       Example 4: Import and clobber commands in the current session
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; Export-PSSession -Session $S -AllowClobber -OutputModule AllCommands</code></pre>
     <p>
      This command exports all commands and all formatting data from the PSSession in the $S variable into the current session.
The command uses the
      <em>
       AllowClobber
      </em>
      parameter to include commands with the same names as commands in the current session.
     </p>
     <p>
      <strong>
       Example 5: Export commands from a closed PSSession
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; $Options = New-PSSessionOption -NoMachineProfile

PS C:\&gt; $S = New-PSSession -ComputerName "Server01" -SessionOption $Options

PS C:\&gt; Export-PSSession -Session $S -OutputModule Server01

PS C:\&gt; Remove-PSSession $S

PS C:\&gt; New-PSSession -ComputerName "Server01" -SessionOption $Options

PS C:\&gt; Import-Module Server01</code></pre>
     <p>
      This example shows how to run the exported commands in a session with particular options when the PSSession from which the commands were exported is closed.
     </p>
     <p>
      When you use
      <strong>
       Export-PSSession
      </strong>
      , it saves information about the original PSSession in the module that it creates.
When you import the module, if the original remote session is closed, the module will use any open remote session that connects to the originating computer.
     </p>
     <p>
      If the current session does not include a remote session to the originating computer, the commands in the module will re-establish a session to that computer.
However,
      <strong>
       Export-PSSession
      </strong>
      does not save special options, such as those set by using the
      <em>
       SessionOption
      </em>
      parameter of New-PSSession, in the module.
     </p>
     <p>
      Therefore, if you want to run the exported commands in a remote session with particular options, you must create a remote session with the options that you want before you import the module.
     </p>
     <p>
      The first command uses the
      <strong>
       New-PSSessionOption
      </strong>
      cmdlet to create a
      <strong>
       PSSessionOption
      </strong>
      object, and it saves the object in the $Options variable.
     </p>
     <p>
      The second command creates a PSSession that includes the specified options.
The command uses the
      <strong>
       New-PSSession
      </strong>
      cmdlet to create a PSSession on the Server01 computer.
It uses the
      <em>
       SessionOption
      </em>
      parameter to submit the option object in $Options.
     </p>
     <p>
      The third command uses the
      <strong>
       Export-PSSession
      </strong>
      cmdlet to export commands from the PSSession in $S to the Server01 module.
     </p>
     <p>
      The fourth command uses the Remove-PSSession cmdlet to delete the PSSession in the $S variable.
     </p>
     <p>
      The fifth command uses the
      <strong>
       New-PSSession
      </strong>
      cmdlet to create a new PSSession that connects to the Server01 computer.
This PSSession also uses the session options in the $Options variable.
     </p>
     <p>
      The sixth command uses the Import-Module cmdlet to import the commands from the Server01 module.
The commands in the module run in the PSSession on the Server01 computer.
     </p>
     <h2 id="required-parameters">
      Required Parameters
     </h2>
     <div class="parameterName stack">
      -OutputModule
     </div>
     <div class="parameterInfo">
      <p>
       Specifies a path (optional) and name for the module that
       <strong>
        Export-PSSession
       </strong>
       creates.
The default path is $home\Documents\WindowsPowerShell\Modules.
This parameter is required.
      </p>
      <p>
       If the module subdirectory or any of the files that
       <strong>
        Export-PSSession
       </strong>
       creates already exist, the command fails.
To overwrite existing files, use the
       <em>
        Force
       </em>
       parameter.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          String
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Aliases:
        </td>
        <td>
         PSPath, ModuleName
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         2
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -Session
     </div>
     <div class="parameterInfo">
      <p>
       Specifies the PSSession from which the commands are exported.
Enter a variable that contains a session object or a command that gets a session object, such as a Get-PSSession command.
This parameter is required.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          PSSession
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         1
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <h2 id="optional-parameters">
      Optional Parameters
     </h2>
     <div class="parameterName stack">
      -AllowClobber
     </div>
     <div class="parameterInfo">
      <p>
       Exports the specified commands, even if they have the same names as commands in the current session.
      </p>
      <p>
       If you import a command with the same name as a command in the current session, the imported command hides or replaces the original commands.
For more information, see about_Command_Precedence.
      </p>
      <p>
       <strong>
        Export-PSSession
       </strong>
       does not import commands that have the same names as commands in the current session.
The default behavior is designed to prevent command name conflicts.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          SwitchParameter
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -ArgumentList
     </div>
     <div class="parameterInfo">
      <p>
       Exports the variant of the command that results from using the specified arguments (parameter values).
      </p>
      <p>
       For example, to export the variant of the Get-Item command in the certificate (Cert:) drive in the PSSession in $S, type
       <code>
        export-pssession -session $s -command get-item -argumentlist cert:
       </code>
       .
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          Object[]
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Aliases:
        </td>
        <td>
         Args
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -Certificate
     </div>
     <div class="parameterInfo">
      <p>
       Specifies the client certificate that is used to sign the format files (
       <em>
        .Format.ps1xml) or script module files (.psm1) in the module that **Export-PSSession
       </em>
       * creates.
Enter a variable that contains a certificate or a command or expression that gets the certificate.
      </p>
      <p>
       To find a certificate, use the Get-PfxCertificate cmdlet or use the Get-ChildItem cmdlet in the Certificate (Cert:) drive.
If the certificate is not valid or does not have sufficient authority, the command fails.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          X509Certificate2
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -CommandName
     </div>
     <div class="parameterInfo">
      <p>
       Exports only the commands with the specified names or name patterns.
Wildcards are permitted.
Use
       <em>
        CommandName
       </em>
       or its alias,
       <em>
        Name
       </em>
       .
      </p>
      <p>
       By default,
       <strong>
        Export-PSSession
       </strong>
       exports all commands from the PSSession except for commands that have the same names as commands in the current session.
This prevents imported commands from hiding or replacing commands in the current session.
To export all commands, even those that hide or replace other commands, use the
       <em>
        AllowClobber
       </em>
       parameter.
      </p>
      <p>
       If you use the
       <em>
        CommandName
       </em>
       parameter, the formatting files for the commands are not exported unless you use the
       <em>
        FormatTypeName
       </em>
       parameter.
Similarly, if you use the
       <em>
        FormatTypeName
       </em>
       parameter, no commands are exported unless you use the
       <em>
        CommandName
       </em>
       parameter.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          String[]
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Aliases:
        </td>
        <td>
         Name
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         3
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -CommandType
     </div>
     <div class="parameterInfo">
      <p>
       Exports only the specified types of command objects.
Use
       <em>
        CommandType
       </em>
       or its alias,
       <em>
        Type
       </em>
       .
      </p>
      <p>
       The acceptable values for this parameter are:
      </p>
      <ul>
       <li>
        Alias: All Windows PowerShell aliases in the current session.
       </li>
       <li>
        All: All command types.
It is the equivalent of "get-command *".
       </li>
       <li>
        Application.
All files other than Windows PowerShell files in paths listed in the Path environment variable ($env:path), including .txt, .exe, and .dll files.
       </li>
       <li>
        Cmdlet.
The cmdlets in the current session.
"Cmdlet" is the default.
       </li>
       <li>
        ExternalScript.
All .ps1 files in the paths listed in the Path environment variable ($env:path).
       </li>
       <li>
        Filter and Function.
All Windows PowerShell functions.
       </li>
       <li>
        Script.
Script blocks in the current session.
       </li>
      </ul>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          CommandTypes
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Aliases:
        </td>
        <td>
         Type
        </td>
       </tr>
       <tr>
        <td>
         Parameter Sets:
        </td>
        <td>
         Alias, Function, Filter, Cmdlet, ExternalScript, Application, Script, Workflow, Configuration, All
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -Encoding
     </div>
     <div class="parameterInfo">
      <p>
       Specifies the encoding for the output files.
The acceptable values for this parameter are:
      </p>
      <ul>
       <li>
        Unicode
       </li>
       <li>
        UTF7
       </li>
       <li>
        UTF8
       </li>
       <li>
        ASCII
       </li>
       <li>
        UTF32
       </li>
       <li>
        BigEndianUnicode
       </li>
       <li>
        Default
       </li>
       <li>
        OEM
       </li>
      </ul>
      <p>
       The default value is UTF-8.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          String
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Parameter Sets:
        </td>
        <td>
         Unicode, UTF7, UTF8, ASCII, UTF32, BigEndianUnicode, Default, OEM
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -Force
     </div>
     <div class="parameterInfo">
      <p>
       Overwrites one or more existing output files, even if the file has the read-only attribute.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          SwitchParameter
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -FormatTypeName
     </div>
     <div class="parameterInfo">
      <p>
       Exports formatting instructions only for the specified Microsoft .NET Framework types.
Enter the type names.
By default,
       <strong>
        Export-PSSession
       </strong>
       exports formatting instructions for all .NET Framework types that are not in the
       <strong>
        System.Management.Automation
       </strong>
       namespace.
      </p>
      <p>
       The value of this parameter must be the name of a type that is returned by a Get-FormatData command in the session from which the commands are being imported.
To get all of the formatting data in the remote session, type
       <code>
        *
       </code>
       .
      </p>
      <p>
       If you use the
       <em>
        FormatTypeName
       </em>
       parameter, no commands are exported unless you use the
       <em>
        CommandName
       </em>
       parameter.
      </p>
      <p>
       Similarly, if you use the
       <em>
        CommandName
       </em>
       parameter, the formatting files for the commands are not exported unless you use the
       <em>
        FormatTypeName
       </em>
       parameter.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          String[]
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         4
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -FullyQualifiedModule
     </div>
     <div class="parameterInfo">
      <p>
       Specifies modules with names that are specified in the form of
       <strong>
        ModuleSpecification
       </strong>
       objects (described in the Remarks section of
       <a data-linktype="external" href="https://msdn.microsoft.com/library/jj136290">
        ModuleSpecification Constructor (Hashtable)
       </a>
       in the MSDN library).
For example, the FullyQualifiedModule parameter accepts a module name that is specified in the format @{ModuleName = "modulename"; ModuleVersion = "version_number"} or @{ModuleName = "modulename"; ModuleVersion = "version_number"; Guid = "GUID"}.
       <strong>
        ModuleName
       </strong>
       and
       <strong>
        ModuleVersion
       </strong>
       are required, but
       <strong>
        Guid
       </strong>
       is optional.
      </p>
      <p>
       You cannot specify the
       <em>
        FullyQualifiedModule
       </em>
       parameter in the same command as a
       <em>
        Module
       </em>
       parameter; the two parameters are mutually exclusive.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          ModuleSpecification[]
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -Module
     </div>
     <div class="parameterInfo">
      <p>
       Exports only the commands in the specified Windows PowerShell snap-ins and modules.
Enter the snap-in and module names.
Wildcards are not permitted.
      </p>
      <p>
       For more information, see about_PSSnapins and Import-Module.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          String[]
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Aliases:
        </td>
        <td>
         PSSnapin
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <h2 id="inputs">
      Inputs
     </h2>
     <p>
      <strong>
       None
      </strong>
     </p>
     <p>
      You cannot pipe objects to
      <strong>
       Export-PSSession
      </strong>
      .
     </p>
     <h2 id="outputs">
      Outputs
     </h2>
     <p>
      <strong>
       System.IO.FileInfo
      </strong>
     </p>
     <p>
      <strong>
       Export-PSSession
      </strong>
      returns a list of files that comprise the module that it created.
     </p>
     <h2 id="notes">
      Notes
     </h2>
     <ul>
      <li>
       <p>
        <strong>
         Export-PSSession
        </strong>
        relies on the Windows PowerShell remoting infrastructure. To use this cmdlet, the computer must be configured for remoting. For more information, see about_Remote_Requirements.
       </p>
       <p>
        You cannot use
        <strong>
         Export-PSSession
        </strong>
        to export a Windows PowerShell provider.
       </p>
       <p>
        Exported commands run implicitly in the PSSession from which they were exported.
However, the details of running the commands remotely are handled entirely by Windows PowerShell.
You can run the exported commands just as you would run local commands.
       </p>
       <p>
        <strong>
         Export-Module
        </strong>
        captures and saves information about the PSSession in the module that it exports.
If the PSSession from which the commands were exported is closed when you import the module, and there are no active PSSessions to the same computer, the commands in the module attempt to re-create the PSSession.
If attempts to re-create the PSSession fail, the exported commands will not run.
       </p>
       <p>
        The session information that
        <strong>
         Export-Module
        </strong>
        captures and saves in the module does not include session options, such as those that you specify in the $PSSessionOption preference variable or by using the
        <em>
         SessionOption
        </em>
        parameter of the New-PSSession, Enter-PSSession, or Invoke-Command cmdlet.
If the original PSSession is closed when you import the module, the module will use another PSSession to the same computer, if one is available.
To enable the imported commands to run in a correctly configured session, create a PSSession with the options that you want before you import the module.
       </p>
       <p>
        To find the commands to export,
        <strong>
         Export-PSSession
        </strong>
        uses the
        <strong>
         Invoke-Command
        </strong>
        cmdlet to run a Get-Command command in the PSSession.
To get and save formatting data for the commands, it uses the Get-FormatData and Export-FormatData cmdlets.
You might see error messages from
        <strong>
         Invoke-Command
        </strong>
        ,
        <strong>
         Get-Command
        </strong>
        ,
        <strong>
         Get-FormatData
        </strong>
        , and
        <strong>
         Export-FormatData
        </strong>
        when you run an
        <strong>
         Export-PSSession
        </strong>
        command.
Also,
        <strong>
         Export-PSSession
        </strong>
        cannot export commands from a session that does not include the
        <strong>
         Get-Command
        </strong>
        ,
        <strong>
         Get-FormatData
        </strong>
        , Select-Object, and Get-Help cmdlets.
       </p>
       <p>
        <strong>
         Export-PSSession
        </strong>
        uses the Write-Progress cmdlet to display the progress of the command.
You might see the progress bar while the command is running.
       </p>
       <p>
        Exported commands have the same limitations as other remote commands, including the inability to start a program with a user interface, such as Notepad.
       </p>
       <p>
        Because Windows PowerShell profiles are not run in PSSessions, the commands that a profile adds to a session are not available to
        <strong>
         Export-PSSession
        </strong>
        .
To export commands from a profile, use an Invoke-Command command to run the profile in the PSSession manually before exporting commands.
       </p>
       <p>
        The module that
        <strong>
         Export-PSSession
        </strong>
        creates might include a formatting file, even if the command does not import formatting data.
If the command does not import formatting data, any formatting files that are created will not contain formatting data.
       </p>
      </li>
     </ul>
     <p>
      *
     </p>
     <h2 id="related-links">
      Related Links
     </h2>
     <ul>
      <li>
       <a data-linktype="relative-path" href="import-pssession.html">
        Import-PSSession
       </a>
      </li>
     </ul>
     <!-- </content> -->
    </main>
    <div class="note alert feedback-system-change-alert">
     <p>
      Note
     </p>
     <p>
      The feedback system for this content will be changing soon. Old comments will not be carried over. If content within a comment thread is important to you, please save a copy. For more information on the upcoming change,
      <a href="https://docs.microsoft.com/teamblog/a-new-feedback-system-is-coming-to-docs">
       we invite you to read our blog post
      </a>
      .
     </p>
    </div>
    <div data-bi-name="comments" id="comments-container" role="form">
    </div>
   </div>
  </div>
  <div class="openfeedback-container" id="openFeedbackContainer">
  </div>
  <div class="action-panel">
  </div>
 </body>
</html>