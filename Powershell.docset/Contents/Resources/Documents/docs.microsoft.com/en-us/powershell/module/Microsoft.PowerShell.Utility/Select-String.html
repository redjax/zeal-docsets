<!DOCTYPE html>
<html class="no-js hasSidebar hasPageActions hasBreadcrumb conceptual" data-authenticated="false" data-render="docs" dir="ltr" lang="en-us">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <meta content="Select-String (Microsoft.PowerShell.Utility)" property="og:title"/>
  <meta content="https://docs.microsoft.com/_themes/docs.theme/master/en-us/_themes/images/microsoft-header.png" property="og:image"/>
  <meta content="summary" name="twitter:card"/>
  <meta content="@docsmsft" name="twitter:site"/>
  <meta content="Select-String (Microsoft.PowerShell.Utility)" name="twitter:title"/>
  <meta content="The Select-String cmdlet searches for text and text patterns in input strings and files. You can use it like Grep in UNIX and Findstr in Windows. You can type Select-String or its alias, sls. Select-â¦" name="twitter:description"/>
  <meta content="https://docs.microsoft.com/_themes/docs.theme/master/en-us/_themes/images/microsoft-header.png" name="twitter:image"/>
  <meta content="Microsoft Logo" name="twitter:image:alt"/>
  <meta content="The Select-String cmdlet searches for text and text patterns in input strings and files. You can use it like Grep in UNIX and Findstr in Windows. You can type Select-String or its alias, sls. Select-â¦" name="description"/>
  <meta content="Docs" name="search.ms_sitename"/>
  <meta content="PowerShell_PowerShell-docs_reference" name="search.ms_docsetname"/>
  <meta content="0" name="version"/>
  <meta content="en-us" name="locale"/>
  <meta content="Docs" name="site_name"/>
  <meta content="PowerShell" name="search.ms_product"/>
  <meta content="PowerShell.PowerShell_PowerShell-docs_reference" name="depot_name"/>
  <meta content="https://github.com/PowerShell/PowerShell-Docs/blob/45404d4ca212afa615798d3d5cbfea5dc5cc1efb/reference/6/Microsoft.PowerShell.Utility/Select-String.md" name="ref_skeleton_gitcommit"/>
  <meta content="https://github.com/PowerShell/PowerShell-Docs/blob/live/reference/6/Microsoft.PowerShell.Utility/Select-String.md" name="original_ref_skeleton_git_url"/>
  <meta content="2018-03-30 03:35 PM" name="updated_at"/>
  <meta content="57c82b0f-a14a-f62c-ab41-8952fd517462" name="document_id"/>
  <meta content="86cda1f5-a5bf-45bd-d7d4-aa1a16134c7d" name="document_version_independent_id"/>
  <meta content="powershell" name="page_type"/>
  <meta content="command" name="page_kind"/>
  <meta content="06/09/2017" name="ms.date"/>
  <meta content="2.0.0" name="schema"/>
  <meta content="powershell,cmdlet" name="keywords"/>
  <meta content="http://go.microsoft.com/fwlink/?LinkId=821853" name="online_version"/>
  <meta content="Microsoft.PowerShell.Commands.Utility.dll-Help.xml" name="external_help_file"/>
  <meta content="powershell" name="ms.devlang"/>
  <meta content="INDEX, FOLLOW" name="ROBOTS"/>
  <meta content="sdwheeler" name="author"/>
  <meta content="sewhee" name="ms.author"/>
  <meta content="carmonm" name="manager"/>
  <meta content="/powershell/bread-pscore/toc.yml?view=powershell-6" name="breadcrumb_path"/>
  <meta content="powershell" name="apiPlatform"/>
  <meta content="reference" name="ms.topic"/>
  <meta content="windows, macos, linux" name="ms.tgt_pltfr"/>
  <meta content="powershell-scripting" name="ms.technology"/>
  <meta content="powershell" name="ms.prod"/>
  <meta content="MSDocsHeader-Powershell" name="uhfHeaderId"/>
  <meta content="../psdocs/toc.json?view=powershell-6" name="toc_rel"/>
  <link href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/select-string" rel="canonical"/>
  <title>
   Select-String
  </title>
  <link href="../../../../_themes/docs.theme/master/en-us/_themes/css/60aac04b.site.css" rel="stylesheet"/>
  <link href="../../../../_themes/docs.theme/master/en-us/_themes/css/fdb8a38a.conceptual.css" rel="stylesheet"/>
 </head>
 <body dir="ltr" lang="en-us">
  <div class="header-holder">
   <div data-bi-name="header" id="headerAreaHolder">
    <div id="uhf-placeholder">
    </div>
   </div>
   <div class="disclaimer-holder" id="disclaimer-holder">
   </div>
  </div>
  <div class="container mainContainer" data-bi-name="body">
   <div class="content-header" data-bi-name="content-header">
    <div class="content-header-controls">
     <button class="contents-button button-border" data-bi-name="contents-expand" type="button">
      <span class="docon docon-menu">
      </span>
      Contents
     </button>
    </div>
    <div class="content-header-controls">
     <button class="ap-collapse-behavior ap-expanded button-border" data-bi-name="ap-collapse" type="button">
      <span class="docon docon-exit-mode">
      </span>
      Exit focus mode
     </button>
    </div>
   </div>
   <div class="primary-holder">
    <main class="content" data-bi-name="content" dir="ltr" id="main" lang="en-us" role="main">
     <!-- <content> -->
     <h1>
      Select-String
     </h1>
     <div class="metadata">
      <dl class="attributeList">
       <dt>
        Module:
       </dt>
       <dd>
        <a data-linktype="relative-path" href="./Microsoft.PowerShell.Utility.html">
         Microsoft.PowerShell.Utility
        </a>
       </dd>
      </dl>
     </div>
     <div class="summaryHolder">
      <div class="summary">
       Finds text in strings and files.
      </div>
     </div>
     <h2 class="hiddenAnchor" id="syntax">
      Syntax
     </h2>
     <pre class="wrap"><code class="lang-powershell" dir="ltr">Select-String
      [-Pattern] &lt;String[]&gt;
      [-Path] &lt;String[]&gt;
      [-SimpleMatch]
      [-CaseSensitive]
      [-Quiet]
      [-List]
      [-Include &lt;String[]&gt;]
      [-Exclude &lt;String[]&gt;]
      [-NotMatch]
      [-AllMatches]
      [-Encoding &lt;String&gt;]
      [-Context &lt;Int32[]&gt;]
      [&lt;CommonParameters&gt;]</code></pre>
     <pre class="wrap"><code class="lang-powershell" dir="ltr">Select-String
      -InputObject &lt;PSObject&gt;
      [-Pattern] &lt;String[]&gt;
      [-SimpleMatch]
      [-CaseSensitive]
      [-Quiet]
      [-List]
      [-Include &lt;String[]&gt;]
      [-Exclude &lt;String[]&gt;]
      [-NotMatch]
      [-AllMatches]
      [-Encoding &lt;String&gt;]
      [-Context &lt;Int32[]&gt;]
      [&lt;CommonParameters&gt;]</code></pre>
     <pre class="wrap"><code class="lang-powershell" dir="ltr">Select-String
      [-Pattern] &lt;String[]&gt;
      -LiteralPath &lt;String[]&gt;
      [-SimpleMatch]
      [-CaseSensitive]
      [-Quiet]
      [-List]
      [-Include &lt;String[]&gt;]
      [-Exclude &lt;String[]&gt;]
      [-NotMatch]
      [-AllMatches]
      [-Encoding &lt;String&gt;]
      [-Context &lt;Int32[]&gt;]
      [&lt;CommonParameters&gt;]</code></pre>
     <h2 id="description">
      Description
     </h2>
     <p>
      The
      <strong>
       Select-String
      </strong>
      cmdlet searches for text and text patterns in input strings and files.
You can use it like Grep in UNIX and Findstr in Windows.
You can type
      <code>
       Select-String
      </code>
      or its alias,
      <code>
       sls
      </code>
      .
     </p>
     <p>
      <strong>
       Select-String
      </strong>
      is based on lines of text.
By default,
      <strong>
       Select-String
      </strong>
      finds the first match in each line and, for each match, it displays the file name, line number, and all text in the line containing the match.
However, you can direct it to detect multiple matches per line, display text before and after the match, or display only a Boolean value (True or False) that indicates whether a match is found.
     </p>
     <p>
      <strong>
       Select-String
      </strong>
      uses regular expression matching, but it can also perform a simple match that searches the input for the text that you specify.
     </p>
     <p>
      <strong>
       Select-String
      </strong>
      can display all of the text matches or stop after the first match in each input file.
It can also display all text that does not match the specified pattern.
You can also specify that
      <strong>
       Select-String
      </strong>
      should expect a particular character encoding, such as when you are searching files of Unicode text.
     </p>
     <h2 id="examples">
      Examples
     </h2>
     <p>
      <strong>
       Example 1: Find a case-sensitive match
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; "Hello","HELLO" | Select-String -Pattern "HELLO" -CaseSensitive</code></pre>
     <p>
      This command performs a case-sensitive match of the text that was piped to the
      <strong>
       Select-String
      </strong>
      command.
     </p>
     <p>
      As a result,
      <strong>
       Select-String
      </strong>
      finds only "HELLO", because "Hello" does not match.
     </p>
     <p>
      Because each of the quoted strings is treated as a line, without the
      <em>
       CaseSensitive
      </em>
      parameter,
      <strong>
       Select-String
      </strong>
      would recognize both of the strings as matches.
     </p>
     <p>
      <strong>
       Example 2: Find matches in XML files only
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; Select-String -Path "*.xml" -Pattern "the the"</code></pre>
     <p>
      This command searches through all files with the .xml file name extension in the current directory and displays the lines in those files that include the string "the the".
     </p>
     <p>
      <strong>
       Example 3: Find a pattern match
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; Select-String -Path "$pshome\en-US\*.txt" -Pattern "@"</code></pre>
     <p>
      This command searches the Windows PowerShell conceptual Help files (about_*.txt) for information about the use of the at sign (@).
     </p>
     <p>
      To indicate the path, this command uses the value of the $pshome automatic variable, which stores the path to the Windows PowerShell installation directory.
In this example, the command searches the en-US subdirectory, which contains the English (US) language Help files for Windows PowerShell.
     </p>
     <p>
      <strong>
       Example 4: Use Select-String in a function
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; function search-help

{

   $pshelp = "$pshome\es\about_*.txt", "$pshome\en-US\*dll-help.xml"

   Select-String -path $pshelp -Pattern $args[0]

}</code></pre>
     <p>
      This simple function uses the
      <strong>
       Select-String
      </strong>
      cmdlet to search the Windows PowerShell Help files for a particular string.
In this example, the function searches the "en-US" subdirectory for English-United States language files.
     </p>
     <p>
      To use the function to find a string, such as "psdrive", type
      <code>
       search-help psdrive
      </code>
      .
     </p>
     <p>
      To use this function in any Windows PowerShell console, change the path to point to the Windows PowerShell Help files on your system, and then paste the function in your Windows PowerShell profile.
     </p>
     <p>
      <strong>
       Example 5: Search for a string in the Application log
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; $Events = Get-EventLog -LogName application -Newest 100

PS C:\&gt; $Events | Select-String -InputObject {$_.message} -Pattern "failed"</code></pre>
     <p>
      This example searches for the string "failed" in the 100 newest events in the Application log in Event Viewer.
     </p>
     <p>
      The first command uses the Get-EventLog cmdlet to get the 100 most recent events from the Application event log.
Then it stores the events in the $Events variable.
     </p>
     <p>
      The second command uses a pipeline operator (|) to send the objects in the $Events variable to
      <strong>
       Select-String
      </strong>
      .
It uses the
      <em>
       InputObject
      </em>
      parameter to represent the input from the $Events variable.
The value of the
      <em>
       InputObject
      </em>
      parameter is the Message property of each object as it travels through the pipeline.
The current object is represented by the $_ symbol.
     </p>
     <p>
      As each event arrives in the pipeline,
      <strong>
       Select-String
      </strong>
      searches the value of its Message property for the "failed" string, and then displays any lines that include a match.
     </p>
     <p>
      <strong>
       Example 6: Find a string in subdirectories
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; Get-ChildItem c:\windows\system32\*.txt -Recurse | Select-String -Pattern "Microsoft" -CaseSensitive</code></pre>
     <p>
      This command examines all files in the subdirectories of C:\Windows\System32 with the .txt file name extension and searches for the string "Microsoft".
The
      <em>
       CaseSensitive
      </em>
      parameter indicates that the "M" in "Microsoft" must be capitalized and that the rest of the characters must be lowercase for
      <strong>
       Select-String
      </strong>
      to find a match.
     </p>
     <p>
      <strong>
       Example 7: Find strings that do not match a pattern
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; Select-String -Path "process.txt" -Pattern "idle, svchost" -NotMatch</code></pre>
     <p>
      This command finds lines of text in the Process.txt file that do not include the words "idle" or "svchost".
     </p>
     <p>
      <strong>
       Example 8: Find lines before and after a match
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; $F = Select-String -Path "audit.log" -Pattern "logon failed" -Context 2, 3

PS C:\&gt; $F.count

PS C:\&gt; ($F)[0].context | Format-List</code></pre>
     <p>
      The first command searches the Audit.Log file for the phrase "logon failed." It uses the
      <em>
       Context
      </em>
      parameter to capture 2 lines before the match and 3 lines after the match.
     </p>
     <p>
      The second command uses the Count property of object arrays to display the number of matches found, in this case, 2.
     </p>
     <p>
      The third command displays the lines stored in the Context property of the first
      <strong>
       MatchInfo
      </strong>
      object.
It uses array notation to indicate the first match (match 0 in a zero-based array), and it uses the Format-List cmdlet to display the value of the Context property as a list.
     </p>
     <p>
      The output consists of two MatchInfo objects, one for each match detected.
The context lines are stored in the Context property of the
      <strong>
       MatchInfo
      </strong>
      object.
     </p>
     <p>
      <strong>
       Example 9: Find all pattern matches
      </strong>
     </p>
     <pre><code class="lang-powershell">PS C:\&gt; $A = Get-ChildItem $pshome\en-us\about*.help.txt | Select-String -Pattern "transcript"

PS C:\&gt; $B = Get-ChildItem $pshome\en-us\about*.help.txt | Select-String -Pattern "transcript" -AllMatches

PS C:\&gt; $A

C:\Windows\system32\WindowsPowerShell\v1.0\en-us\about_Pssnapins.help.txt:39:       Start-Transcript and Stop-Transcript. PS C:\&gt; $B

C:\Windows\system32\WindowsPowerShell\v1.0\en-us\about_Pssnapins.help.txt:39:       Start-Transcript and Stop-Transcript. PS C:\&gt; $A.matches

Groups   : {Transcript}

Success  : True

Captures : {Transcript}

Index    : 13

Length   : 10

Value    : Transcript PS C:\&gt; $B.matches



Groups   : {Transcript}

Success  : True

Captures : {Transcript}

Index    : 13

Length   : 10

Value    : Transcript

Groups   : {Transcript}

Success  : True

Captures : {Transcript}

Index    : 33

Length   : 10

Value    : Transcript</code></pre>
     <p>
      This example demonstrates the effect of the
      <em>
       AllMatches
      </em>
      parameter of
      <strong>
       Select-String
      </strong>
      .
      <em>
       AllMatches
      </em>
      finds all pattern matches in a line, instead of just finding the first match in each line.
     </p>
     <p>
      The first command in the example searches the Windows PowerShell conceptual Help files ("about" Help) for instances of the word "transcript".
The output of the first command is saved in the $A variable.
     </p>
     <p>
      The second command is identical, except that it uses the
      <em>
       AllMatches
      </em>
      parameter.
The output of the second command is saved in the $B variable.
     </p>
     <p>
      When you display the value of the variables, the default display is identical, as shown in the example output.
     </p>
     <p>
      However, the fifth and sixth commands display the value of the Matches property of each object.
The Matches property of the first command contains just one match (that is, one
      <strong>
       System.Text.RegularExpressions.Match
      </strong>
      object), whereas the Matches property of the second command contains objects for both of the matches in the line.
     </p>
     <h2 id="required-parameters">
      Required Parameters
     </h2>
     <div class="parameterName stack">
      -InputObject
     </div>
     <div class="parameterInfo">
      <p>
       Specifies the text to be searched.
Enter a variable that contains the text, or type a command or expression that gets the text.
      </p>
      <p>
       Using the
       <em>
        InputObject
       </em>
       parameter is not the same as piping strings to
       <strong>
        Select-String
       </strong>
       .
The differences are as follows:
      </p>
      <ul>
       <li>
        When you pipe more than one string (a collection) to
        <strong>
         Select-String
        </strong>
        ,
        <strong>
         Select-String
        </strong>
        searches for the specified text in each string and returns each string that contains the search text.
       </li>
       <li>
        When you use the
        <em>
         InputObject
        </em>
        parameter to submit a collection of strings,
        <strong>
         Select-String
        </strong>
        treats the collection as a single combined string and returns the strings as a unit if it finds the search text in any string.
       </li>
      </ul>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          PSObject
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         True (ByValue)
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -LiteralPath
     </div>
     <div class="parameterInfo">
      <p>
       Specifies the path to the files to be searched.
Unlike
       <strong>
        Path
       </strong>
       , the value of the
       <strong>
        LiteralPath
       </strong>
       parameter is used exactly as it is typed.
No characters are interpreted as wildcards.
If the path includes escape characters, enclose it in single quotation marks.
Single quotation marks tell Windows PowerShell not to interpret any characters as escape sequences.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          String[]
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Aliases:
        </td>
        <td>
         PSPath
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         True (ByPropertyName)
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -Path
     </div>
     <div class="parameterInfo">
      <p>
       Specifies the path to the files to search.
Wildcards are permitted.
The default location is the local directory.
      </p>
      <p>
       Specify files in the directory, such as log1.txt,
       <em>
        .doc, or *.
       </em>
       .
If you specify only a directory, the command fails.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          String[]
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         2
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         True (ByPropertyName)
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -Pattern
     </div>
     <div class="parameterInfo">
      <p>
       Specifies the text to find.
Type a string or regular expression.
If you type a string, use the
       <em>
        SimpleMatch
       </em>
       parameter.
      </p>
      <p>
       To learn about regular expressions, see about_Regular_Expressions.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          String[]
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         1
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <h2 id="optional-parameters">
      Optional Parameters
     </h2>
     <div class="parameterName stack">
      -AllMatches
     </div>
     <div class="parameterInfo">
      <p>
       Indicates that the cmdlet searches for more than one match in each line of text.
Without this parameter,
       <strong>
        Select-String
       </strong>
       finds only the first match in each line of text.
      </p>
      <p>
       When
       <strong>
        Select-String
       </strong>
       finds more than one match in a line of text, it still emits only one
       <strong>
        MatchInfo
       </strong>
       object for the line, but the Matches property of the object contains all of the matches.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          SwitchParameter
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -CaseSensitive
     </div>
     <div class="parameterInfo">
      <p>
       Indicates that the cmdlet makes matches case-sensitive.
By default, matches are not case-sensitive.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          SwitchParameter
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -Context
     </div>
     <div class="parameterInfo">
      <p>
       Captures the specified number of lines before and after the line with the match.
This allows you to view the match in context.
      </p>
      <p>
       If you enter one number as the value of this parameter, that number determines the number of lines captured before and after the match.
If you enter two numbers as the value, the first number determines the number of lines before the match and the second number determines the number of lines after the match.
      </p>
      <p>
       In the default display, lines with a match are indicated by a right angle bracket (ASCII 62) in the first column of the display.
Unmarked lines are the context.
      </p>
      <p>
       This parameter does not change the number of objects generated by
       <strong>
        Select-String
       </strong>
       .
       <strong>
        Select-String
       </strong>
       generates one
       <strong>
        MatchInfo
       </strong>
       (
       <strong>
        Microsoft.PowerShell.Commands.MatchInfo
       </strong>
       ) object for each match.
The context is stored as an array of strings in the Context property of the object.
      </p>
      <p>
       When you pipe the output of a
       <strong>
        Select-String
       </strong>
       command to another
       <strong>
        Select-String
       </strong>
       command, the receiving command searches only the text in the matched line (the value of the Line property of the
       <strong>
        MatchInfo
       </strong>
       object), not the text in the context lines.
As a result, the
       <em>
        Context
       </em>
       parameter is not valid on the receiving
       <strong>
        Select-String
       </strong>
       command.
      </p>
      <p>
       When the context includes a match, the
       <strong>
        MatchInfo
       </strong>
       object for each match includes all of the context lines, but the overlapping lines appear only once in the display.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          Int32[]
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -Encoding
     </div>
     <div class="parameterInfo">
      <p>
       Specifies the character encoding that
       <strong>
        Select-String
       </strong>
       should assume when searching the file.
The default is UTF8.
      </p>
      <p>
       The acceptable values for this parameter are:
      </p>
      <ul>
       <li>
        Unicode
       </li>
       <li>
        UTF7
       </li>
       <li>
        UTF8
       </li>
       <li>
        UTF32
       </li>
       <li>
        ASCII
       </li>
       <li>
        BigEndianUnicode
       </li>
       <li>
        Default
       </li>
       <li>
        OEM
       </li>
      </ul>
      <p>
       Default is the encoding of the system's current ANSI code page.
OEM is the current original equipment manufacturer code page identifier for the operating system.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          String
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Parameter Sets:
        </td>
        <td>
         unicode, utf7, utf8, utf32, ascii, bigendianunicode, default, oem
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -Exclude
     </div>
     <div class="parameterInfo">
      <p>
       Exclude the specified items.
The value of this parameter qualifies the
       <em>
        Path
       </em>
       parameter.
Enter a path element or pattern, such as *.txt.
Wildcards are permitted.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          String[]
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -Include
     </div>
     <div class="parameterInfo">
      <p>
       Specifies an array of items that the cmdlet excludes from the operation.
The value of this parameter qualifies the
       <em>
        Path
       </em>
       parameter.
Enter a path element or pattern, such as *.txt.
Wildcards are permitted.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          String[]
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -List
     </div>
     <div class="parameterInfo">
      <p>
       Indicates that the cmdlet returns only the first match in each input file.
By default,
       <strong>
        Select-String
       </strong>
       returns a
       <strong>
        MatchInfo
       </strong>
       object for each match it finds.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          SwitchParameter
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -NotMatch
     </div>
     <div class="parameterInfo">
      <p>
       Indicates that the cmdlet finds text that does not match the specified pattern.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          SwitchParameter
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -Quiet
     </div>
     <div class="parameterInfo">
      <p>
       Indicates that the cmdlet returns a Boolean value (True or False), instead of a
       <strong>
        MatchInfo
       </strong>
       object.
The value is True if the pattern is found; otherwise, the value is False.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          SwitchParameter
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <div class="parameterName stack">
      -SimpleMatch
     </div>
     <div class="parameterInfo">
      <p>
       Indicates that the cmdlet uses a simple match rather than a regular expression match.
In a simple match,
       <strong>
        Select-String
       </strong>
       searches the input for the text in the
       <em>
        Pattern
       </em>
       parameter.
It does not interpret the value of the
       <em>
        Pattern
       </em>
       parameter as a regular expression statement.
      </p>
      <table class="nameValue stack">
       <tr>
        <td>
         Type:
        </td>
        <td>
         <span class="xref">
          SwitchParameter
         </span>
        </td>
       </tr>
       <tr>
        <td>
         Position:
        </td>
        <td>
         Named
        </td>
       </tr>
       <tr>
        <td>
         Default value:
        </td>
        <td>
         None
        </td>
       </tr>
       <tr>
        <td>
         Accept pipeline input:
        </td>
        <td>
         False
        </td>
       </tr>
       <tr>
        <td>
         Accept wildcard characters:
        </td>
        <td>
         False
        </td>
       </tr>
      </table>
     </div>
     <h2 id="inputs">
      Inputs
     </h2>
     <p>
      <strong>
       System.Management.Automation.PSObject
      </strong>
     </p>
     <p>
      You can pipe any object that has a ToString method to
      <strong>
       Select-String
      </strong>
      .
     </p>
     <h2 id="outputs">
      Outputs
     </h2>
     <p>
      <strong>
       Microsoft.PowerShell.Commands.MatchInfo or System.Boolean
      </strong>
     </p>
     <p>
      By default, the output is a set of
      <strong>
       MatchInfo
      </strong>
      objects, one for each match found.
If you use the
      <em>
       Quiet
      </em>
      parameter, the output is a Boolean value indicating whether the pattern was found.
     </p>
     <h2 id="notes">
      Notes
     </h2>
     <ul>
      <li>
       <strong>
        Select-String
       </strong>
       is like the Grep command in UNIX and the FindStr command in Windows.
      </li>
      <li>
       The
       <strong>
        sls
       </strong>
       alias for the
       <strong>
        Select-String
       </strong>
       cmdlet was introduced in Windows PowerShell 3.0.
      </li>
      <li>
       <p>
        To use
        <strong>
         Select-String
        </strong>
        , type the text that you want to find as the value of the
        <em>
         Pattern
        </em>
        parameter.
       </p>
       <p>
        To specify the text to be searched, do the following:
       </p>
       <ul>
        <li>
         <p>
          Type the text in a quoted string, and then pipe it to
          <strong>
           Select-String
          </strong>
          .
         </p>
        </li>
        <li>
         <p>
          Store a text string in a variable, and then specify the variable as the value of the
          <em>
           InputObject
          </em>
          parameter.
         </p>
        </li>
        <li>
         <p>
          If the text is stored in files, use the
          <em>
           Path
          </em>
          parameter to specify the path to the files.
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p>
        By default,
        <strong>
         Select-String
        </strong>
        interprets the value of the
        <em>
         Pattern
        </em>
        parameter as a regular expression. (For more information, see about_Regular_Expressions.) However, you can use the
        <em>
         SimpleMatch
        </em>
        parameter to override the regular expression matching. The
        <em>
         SimpleMatch
        </em>
        parameter finds instances of the value of the
        <em>
         Pattern
        </em>
        parameter in the input.
       </p>
      </li>
      <li>
       The default output of
       <strong>
        Select-String
       </strong>
       is a
       <strong>
        MatchInfo
       </strong>
       object, which includes detailed information about the matches. The information in the object is useful when you are searching for text in files, because
       <strong>
        MatchInfo
       </strong>
       objects have properties such as Filename and Line. When the input is not from the file, the value of these parameters is InputStream.
      </li>
      <li>
       If you do not need the information in the
       <strong>
        MatchInfo
       </strong>
       object, use the
       <em>
        Quiet
       </em>
       parameter, which returns a Boolean value (True or False) to indicate whether it found a match, instead of a
       <strong>
        MatchInfo
       </strong>
       object.
      </li>
      <li>
       When matching phrases,
       <strong>
        Select-String
       </strong>
       uses the current culture that is set for the system. To find the current culture, use the Get-Culture cmdlet.
      </li>
      <li>
       <p>
        To find the properties of a
        <strong>
         MatchInfo
        </strong>
        object, type the following:
       </p>
       <p>
        <code>
         Select-String -Path test.txt -Pattern "test" | Get-Member | Format-List -Property *
        </code>
       </p>
      </li>
     </ul>
     <h2 id="related-links">
      RELATED LINKS
     </h2>
     <!-- </content> -->
    </main>
    <div class="note alert feedback-system-change-alert">
     <p>
      Note
     </p>
     <p>
      The feedback system for this content will be changing soon. Old comments will not be carried over. If content within a comment thread is important to you, please save a copy. For more information on the upcoming change,
      <a href="https://docs.microsoft.com/teamblog/a-new-feedback-system-is-coming-to-docs">
       we invite you to read our blog post
      </a>
      .
     </p>
    </div>
    <div data-bi-name="comments" id="comments-container" role="form">
    </div>
   </div>
  </div>
  <div class="openfeedback-container" id="openFeedbackContainer">
  </div>
  <div class="action-panel">
  </div>
 </body>
</html>